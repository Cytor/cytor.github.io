{"pages":[{"title":"关于我","text":"My name is lankning. I’m a student out of CS area. And more precisely, i’m major in machnical engineering in my undergradute career. Now i’m preparing for my postgraduate test. 我对于写代码很感兴趣，因为这是一个可以自由发挥的世界。我写博客的原因也很简单，只是记录一下自己的生活（主要是学习方面的）。 我的专业要求我会一点工具语言，同时实验室需要机器学习方向的人。因此我了解一些C，C#，Matlab以及Python语言的编程。 我爱运动，最喜欢的是足球，然而一般只能踢动半场；次喜欢的是游泳，可惜游泳的机会比较少；接着就到羽毛球和钓鱼了。 同时，我还是一个吃货，喜欢各种的美食，还喜欢自己动手做（暗黑料理除外），上图。","link":"/about/index.html"}],"posts":[{"title":"deepin安装hexo","text":"那是一个风雪交加的晚上，我把windows的系统引导分区efi删掉了。卒。 遂清空磁盘，安装deepin。 更新包 1sudo apt-get update 安装nodejs和npm 官方有说是install nodejs和npm，然而我试了一下，我不能直接install npm。安装node和nodejs-bin替代。 1sudo apt-get install node nodejs-bin 使用淘宝镜像安装hexo 如果不使用淘宝镜像安装就会报出一堆错误。 1sudo npm install -g hexo --registry=https://registry.npm.taobao.org 安装git 12sudo apt-get install gitnpm install --save hexo-deployer-git 如果不安装hexo-deployer-git，可能会报错 ERROR Deployer not found: git 参考资料： 1、hexo安装错误err! 2、hexo文档","link":"/2019/12/24/hexo/deepin%E5%AE%89%E8%A3%85hexo/"},{"title":"hexo中git的配置","text":"hexo框架下文章写好并生成之后需要推送到GitHub或者其他具有静态页面托管的平台上面，然而一般都会发生很多问题。 一、报错 ERROR Deployer not found: git 安装hexo-deployer-git 1npm install --save hexo-deployer-git 二、报错Please tell me who you are. 设置自己的GitHub邮箱号和用户名 12git config --global user.email &quot;you@example.com&quot;git config --global user.name &quot;Your Name&quot; 三、一次性推送到多个平台，该怎么做？ 这个问题很简单，只需要在根目录的config文件里修改即可。 打开”_config.yml”文件，在最下面将deploy那一块代码修改为如下形式即可。 1234567deploy: type: git repo: gitee: 你的gitee仓库提交地址 github: 你的github仓库提交地址 coding: 你的coding仓库提交地址 branch: master — 我是分割线 — 百度上那些扯什么公钥、ssh的，Windows下没有必要，真的。 当在windows环境下，在git bash里面输入“hexo d”进行提交的时候，会自动弹出一个窗口让你输入你每个平台的用户名和密码，第一次完成之后，以后每次提交都不需要输入账户密码等额外操作了。","link":"/2019/11/18/hexo/hexo%E4%B8%ADgit%E7%9A%84%E9%85%8D%E7%BD%AE/"},{"title":"hexo的icarus主题配置记录","text":"刚刚上手的hexo默认的是lanscape主题，而网上流行的主要是next主题，前者太丑，后者太简单，于是我选来选去选择了icarus主题。本篇主要记录hexo的icarus主题配置过程中的一些疑难问题以及解决办法。 1、新建markdown文件的头部写法 我一开始生成了pages之后发现我没有categories，怎么办呢？在创建hexo新文章的时候，默认只会给出title, date, tags三个选项，我们需要把他们扩充成下面几项。其中thumbnail是预览页面展示的图片。 12345title: hexo icarus主题配置的记录date: 2019-11-22 19:22:30categories: [hexo]tags: [hexo]thumbnail: https://blog.zhangruipeng.me/hexo-theme-icarus/images/logo.svg 2、加入评论系统 我这里使用的是gitment。 Gitment是imsun实现的一款基于 GitHub Issues 的评论系统。支持在前端直接引入，不需要任何后端代码。可以在页面进行登录、查看、评论、点赞等操作，同时有完整的 Markdown / GFM 和代码高亮支持。尤为适合各种基于 GitHub Pages 的静态博客或项目页面。 虽然 Gitment 只能使用 GitHub 账号进行评论，但考虑到博客受众，这是可以接受的。 操作步骤结合icarus作者的教程以及imsun的博客。 需要在主题下的config文件中修改原来的comment部分为： 123456comment: type: gitment owner: xxxxxxxx # (required) GitHub user name repo: xxxxxxxx # (required) GitHub repository name client_id: xxxxxxxx # (required) OAuth application client id client_secret: xxxxxxxx # (required) OAuth application client secret 发现激活不成功，经过搜索，将layout目录下的gitment.ejs这个文件中的两行代码改掉即可。 原来为： 12&lt;link rel=&quot;stylesheet&quot; href=&quot;https://imsun.github.io/gitment/style/default.css&quot;&gt;&lt;script src=&quot;https://imsun.github.io/gitment/dist/gitment.browser.js&quot;&gt;&lt;/script&gt; 修改为： 12&lt;link rel=&quot;stylesheet&quot; href=&quot;https://billts.site/extra_css/gitment.css&quot;&gt;&lt;script src=&quot;https://billts.site/js/gitment.js&quot;&gt;&lt;/script&gt; 3、左边个人信息栏更换图标 原主题给定的是Github, Facebook, Twitter, Dribbble, RSS这六个网页，不符合中国大陆网友的一般习惯（至少不符合我的使用习惯），于是我想把这六个改为Github, Gitee, Bilibili这三个。 仔细查询之后发现theme的config里面使用的是Fontawesome的图标，自己想要什么图标上去搜就好了，注意还要把原来的link替换成自己的。需要重点注意的是，Github之类的这些分类冒号后面不能写注释，一写就报错。修改如下： 12345678910social_links: Github: icon: fab fa-github url: 'https://github.com/Cytor/' Gitee: icon: fab fa-git-square url: 'https://gitee.com/cytor' Bilibili: icon: fas fa-tv-retro url: 'https://space.bilibili.com/390519714' 参考资料 1.icarus作者博客 2.icarus作者Github 3.gitment作者博客 4.解决hexo gitment 的object ProgressEvent问题","link":"/2019/11/22/hexo/hexo%E7%9A%84icarus%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE%E8%AE%B0%E5%BD%95/"},{"title":"在hexo中使用本地图片","text":"在hexo中新建.md文件写markdown的时候希望插入本地图片，而当使用hexo generate命令之后发现生成的网页中根本没有相应的图片。这个时候该怎么办呢？ 【2020.8.25新增】最好的办法：创建asset 假设在 12345MacGesture2-Publish├── apppicker.jpg├── logo.jpg└── rules.jpgMacGesture2-Publish.md 这样的目录结构（目录名和文章名一致），只要使用 ![logo](MacGesture2-Publish/logo.jpg)就可以插入图片。 生成的结构为 12345public/2015/10/18/MacGesture2-Publish├── apppicker.jpg├── index.html├── logo.jpg└── rules.jpg 同时，生成的 html 是 1&lt;img src=&quot;/2015/10/18/MacGesture2-Publish/logo.jpg&quot; alt=&quot;logo&quot;&gt; 而不是愚蠢的 1&lt;img src=&quot;MacGesture2-Publish/logo.jpg&quot; alt=&quot;logo&quot;&gt; 参考链接：https://www.cnblogs.com/lmf-techniques/articles/6911051.html 原文办法一：从路径入手，虽然比较笨笨，但目前看来还算行之有效。 办法二：简单，使用图床服务。 如果我有两篇文章要写，第一篇标题是“如何撩妹”，第二篇的题目是“如何哄女孩开心” 办法一详细步骤如下： 在_posts路径下新建两篇文章对应名字的文件夹。当在markdown写文章的时候，把本地图片放到对应的文件夹里面。 文件夹结构如下所示： _posts/ 如何撩妹.md 如何撩妹/ 如何哄女孩开心.md 如何哄女孩开心/ 文章写好后，使用”hexo generate”命令自动生成静态网页。 我们进入到“public”文件夹里面看，文章在“./2019/10/21/如何撩妹”和“./2019/10/21/如何哄女孩开心”这个文件夹里面。 一开始的时候文章.md文件和对应的图片文件夹是平行的，而这里跟文章同级的目录并没有对应的照片文件夹。 所以我们将“如何撩妹/”和“如何哄女孩开心/”这个文件夹从“source/_posts/“文件夹复制到对应的“public”文章目录下，和html文件同级。如图： 办法二详细步骤如下： 百度图床服务，我这里使用的是“路过图床“ 注册一个账号 将要使用的图片上传到图床，可以得到图片的地址，如图： 接下来就能在markdown里面应用啦！","link":"/2019/10/21/hexo/%E5%9C%A8hexo%E4%B8%AD%E4%BD%BF%E7%94%A8%E6%9C%AC%E5%9C%B0%E5%9B%BE%E7%89%87/"},{"title":"CAD课程总结","text":"CAD这门课不是太难，主要是一些程序性的东西。 题型 对应章 题数 分值 工程数据的处理 3 1 15 图形坐标变换与裁剪 4 2 30 参数化绘图程序设计 ５ 1 15 AutoCAD二次开发 7 1 10 一、工程数据的处理 拉格朗日插值法的几何解释 以二次插值法为例，设$y=a_0+a_1x+a_2x^2$，用已知的ＡＢＣ三点代入求解$a_0,a_1,a_2$即可。 插值法的选点－－选最近的几个点 最小二乘法的损失公式 $$\\phi=\\sum_{i=1}^N(P(x_i)-y_i)$$ 二、图形坐标变换与裁剪 三、参数化绘图 四、CAD二次开发略","link":"/2020/06/04/%E5%AD%A6%E7%A7%91%E7%AC%94%E8%AE%B0/CAD%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93/"},{"title":"AutoCAD绘图基操","text":"2020年5月份，我终于再次更新了一篇文章。主要是CAD课程结课要用到Autocad绘制二维图，期间遇到很多初学者的问题，记录在本文。 一、绘制A3图纸并保存到块 矩形命令rect选择基点后可以用D来规定长宽 命令X可以使线段独立 命令overkill可以去除重叠线段 ctrl+鼠标右键可以快速选择捕捉点类型和设置 二、如何修改线型 为了不让线型互相干扰，需要新建图层 2020版本CAD的图层在常用-图层-图层特性内 线性的选择就在图层特性管理器内 一般轴线使用Center线型（点划线），虚线使用Hidden线型 三、圆角失败点击圆角之后，要先输入R半径，再才能选定两边 有用的命令 命令 意义 tr 裁剪线段 mirror 镜像 x+空格 分离粘连的线段 overkill 删除重复的线段 标注直径$\\phi$ 在尺寸前面加上%%c 参考文献： 1、https://jingyan.baidu.com/article/29697b91e1eaffeb21de3c3a.html 2、https://zhidao.baidu.com/question/430701680.html","link":"/2020/05/31/%E5%AD%A6%E7%A7%91%E7%AC%94%E8%AE%B0/AutoCAD%E7%BB%98%E5%9B%BE%E5%9F%BA%E6%93%8D/"},{"title":"产品数据管理期末题","text":"产品数据管理期末大作业答案。 1、Review of PDM history and main functions. （简述PDM产生的背景、发展历程和主要功能，英文答题） 背景：在 20世纪的60、70年代，企业在其设计和生产过程中开始使用CAD、CAM等技术，新技术的应用在促进生产力发展的同时也带来了新的挑战，主要包括：企业在产品开发过程中需存储与管理大量数据；异构计算机应用系统需要信息集成以及在更高层次上企业在生产过程中需要实现过程集成。到了20世纪80年代，关系数据库技术得到飞速的发展，并得到广泛的应用。产品数据管理(Product Data Management，PDM)正是在这一背景下应运而生的一项新的管理思想和技术 历程： 配合CAD工具的PDM系统：这些产品的目标主要是解决大量电子数据的存储和管理问题，提供了维护“电子绘图仓库”的功能。它仅在一定程度上缓解了“信息孤岛”问题，仍普遍存在功能较弱、集成能力和开放程度较低等问题。 专业PDM产品产生：在第二代PDM出现了许多新功能，如对产品生命周期内多种形式产品数据的管理能力、产品结构与配置管理、电子数据发布和更改控制、基于成组技术的零件分类管理等，同时软件的集成能力和开放程度也有较大提高，少数优秀的PDM产品可以真正实现企业级的信息集成和过程集成。 PDM的标准化阶段：1997年2月，OMG组织公布了其PDM Enabler标准草案，使得不同PDM可以互操作。 CPC和PLM：即协同产品商务和产品全生命周期管理，基于网络的分布式计算技术、Web和Java技术等的应用。 功能： 文档管理：文档分类；文档审批发放；浏览与圈阅 产品结构管理：零部件分类管理；BOM多视图管理 工程更改管理：更改流程；发布管理 应用集成：PDM的管理的主要对象来源于CAD系统，因此每一个PDM系统都有与之相对应的CAD系统，并且有很好的集成。 2、简述文档管理的主要内容和功能 主要内容（网上答案）：分类与查询管理、物理存储策略、逻辑组织机制、浏览与圈阅、审批发放流程、版本管理、权限控制。 主要内容（课件答案）： 实现文档的层次与联系控制 通过权限控制来保证产品数据的完整性与安全性 提供快速有效的信息访问 实现以产品数据为核心的信息共享 功能：通过文档管理，可以让企业很好地组织、管理、控制文档的建立、修改、发布和存档工作。企业人员也可以更加方便、快捷、有效地查找和引用所需要的各种数据和信息。 3、阐述你对产品结构和配置管理的认识 产品结构和配置管理是产品组织和管理的一种形式，它以电子仓库为底层支持，以材料明细表为其组织核心，把定义最终产品的所有工程数据和文档联系起来，实现产品数据的组织、管理与控制，并在一定目标或规则约束下，向用户或应用系统提供产品结构的不同视图和描述，如设计视图、装配视图、制造视图计划视图等。 产品结构是对产品构成的描述，是产品的基本特征。产品结构管理的作用主要有：1）描述产品的零部件组成，包括这些零部件的结构关系、数量和版本；2）物料清单是PDM与ERP进行集成的核心数据对象，它可以由产品结构信息按一定规律导出；3）产品结构是组织与产品相关数据的核心，通过它可以查找到产品中用了哪些零部件，各零部件被用到哪些产品中，与各零部件相关的有哪些文档 ；4）能在产品结构上方便地查看产品、部件、零件和文档的版本信息 产品配置是和产品结构紧密相关的概念，是指对被描述在技术文档中或者体现在产品实际使用过程中的产品功能特性和物理特性进行表示。由于对产品的特性需求最终是通过实际的产品结构来实现的，因此产品配置的结果是具体的产品结构。其作用主要有：1）确保产品结构信息的正确性和可回溯性；2）尽量以面向订单的配置来满足客户对产品及功能的个性化需求，减少重复设计；3）通过配置来管理相似产品，简化产品维护工作，减少产品数据量；4）支持企业减少产品的内部多样化，增加产品的外部多样化，实现从批量生产向批量定制的转换。 4、回答产品开发过程中工程变更的定义以及PDM的对策 工程变更是指在设计完成，各种图纸、文档即将发布或正式发布之后，再针对设计中的尺寸、形状、公差、功能、材料等方面出现的问题所作的一些修改。 基于PDM的变更管理正是为解决上述问题提供了有效途径。首先PDM能够提供给企业一个协同的公共平台，以实现信息的交流与共享，这就消除了企业中各个独立的应用系统所造成的“信息孤岛”现象，不但保证了变更数据高效地在各部门、人员之间的正确流动，而且还能保证数据在变更前后的完整性、一致性。其次，借助PDM中的过程管理、数据对象的生命周期管理等．可以动态地追踪数据的实时状态以及对数据历史状态的追溯，这为管理者实时监控变更活动、有目的地推动或调整变更流程提供了可靠的依据。 5、简述企业应用集成的不同层次及集成方式 不同层次： 封装：电子文件保存在PDM中，在需要时启动应用工具编辑，并能够将修改后的电子文件保存回PDM系统。 单向集成：在封装的基础上，还能提供集成接口从电子文件中提取的管理信息，如图纸的图号、名称、材料等。 双向集成：一般只在同一软件公司提供的产品才可以实现。在PDM和应用系统中都可以处理产品数据，并能够保证数据的一致性。 集成方法： API函数接口：由PDM调用应用提供的API函数来获取需要的信息 交换文件：应用系统与PDM预先约定，双方按约定输出或读入标准格式的交换文件 共享数据库：同样是预先约定，只是输入/输出都是基于共享数据集 共用数据库：应用系统与PDM使用的是一个数据库 参考资料： 1、简述PDM 产生的背景、发展历程及主要功能 2、清华——产品数据管理.ppt","link":"/2019/11/21/%E5%AD%A6%E7%A7%91%E7%AC%94%E8%AE%B0/%E4%BA%A7%E5%93%81%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E6%9C%9F%E6%9C%AB%E9%A2%98/"},{"title":"先进制造技术课程笔记","text":"临时抱佛脚的我又来了，罗列了先进制造技术这门课的问题。 一、能场部分注1：EDM – Electrical Discharging Manufacturing 注2：EFM – Energy Field Manufacturing 1、创新与发明的区别在哪里？ 答：创新（invention）是在已有事物的基础上进行某一方面的改动，比如，将电灯泡的灯丝材质由碳丝替换成钨丝。发明（innovation）相比于创新具有更强的创造性，一般是指从无到有的一个过程，比如合成一种全新的发动机材料、提出一套全新的运行方案。 2、能场的本质是什么？ 答：是一种能量的分布形式，它能够向物体做功或者改变系统的状态。 The energy field is the spatial and temporal distribution of energy. The distributions of froces and energy are energy fields. 3、能场制造中的能场具有哪些形式？请列举出相应的例子，并说明能量与材料的具体作用原理。 答：力、电、光、辐射、热。增材制造：一种材料能从多个方向吸收能场的能量，吸收能量之后就会到达一个跟原来材料分离的状态而独立出来。 4、What are the two principal types of EDM processes? Describe the EDM process mechanism. a) type 1, die-sinking EDM; type 2, wire EDM (WEDM); b) EDM Process: Firstly, we move the tool immersed in dielectric liquid close to the workpiece. Then the dielectric liquid between the two electrodes breaks down and suddenly becomes conductive which contributes to high temperature. As a result, the surface of the workpiece will be removed. 5、Explain the different methods used to improve ﬂushing in EDM. a) controlling the fluid flow (normal flow, reverse flow, jet flushing, and immersion flushing); b) modifying the electrode shape; c) imparting relative movement between the workpiece and the tool electrode. 6、Why vibration can improve EDM process? The high-frequency pumping action of the vibrating surface accelerates the slurry circulation and reduces the machining time. The vibrations can be imparted either to the workpiece or the tool electrode. These vibrations introduce acoustic streaming in the dielectric tank and particles move along this stream. 英 中 ultrasonic 超声波 spatial 空间性 temporal 瞬时性 utilize 应用 二、激光部分 1、What are the general advantages and disadvantages of material processing with laser radiation? Advantages:a. The conversion of laser energy into thermal energy at the workpiece enables processing with a much higher quality.b. In terms of energy field manufacturing, laser energy can be tailored to the material properties allowing a very flexible adjustment of the interaction that can lead to vaporization, melting, or just surface modification. Disadvantages:a. the relatively low electrical to laser optical conversion efficiency.b. the high investment costs 2、Which are the processing parameters during laser cutting? Show their interdependency. Processing parameters: 符号 含义 d thickness of sheet 板材厚度 v cutting speed 切割速率 P laser power 激光功率 A absorptivity 吸收率 Interdependency: a. With the same material and laser power(P), d and v are negatively correlated.b. With the same material and thickness of sheet(d), P and v are positively correlated.c. With the same environment, A and v is positively correlated. It means the speed of cutting willbe improved while the absorptivity is higher.d. The value of A is affected by the material properties, such as melting temperaD ture, density, and the specific thermal capacity 3、Describe photochemical processing and photothermal processing. Discuss the relationship between laser pulse duration and the thermal relaxation time, in another word, laser excited electronic states and thermalization rate, in these two processes photochemical processing. Conclusion: Laser pulse duration and the thermal relaxation time are are positively correlated, which means the thermal relaxation time will be reduced when laser pulse duration is reduced. Inference: We can use TT to represent the duration of laser pulse, while f=1Tf=1T. So when TT becomes lower, ff will become higher. Due to the relationship of P=W∗fP=W∗f, where PP is a constant, so WW will be lower. It is easy to know the positive relationship between PP and dd (the penetration depth of laser), so dd will be lower, too. The formula to calculate thermal relaxation time can be presented as below:$$t_r=\\frac{d^2}{4k}$$where kk is also a constant that stands for the demision of heat dispersion. So if the duration of laser pulse is reduced, the thermal relaxation time will also be reduced. 4、Describe the advantages of laser surface processing over mechanical, chemical, and electric discharge texturing. Name three applications of laser surface processing. Advantages over mechanical texturing: a. The laser power density is high, and the workpiece absorbs the laser and the temperature rises rapidly to melt or vaporize. Even materials with high melting point, high hardness and brittleness (such as ceramics, diamonds, etc.) can be processed by laser. b. The laser head is not in contact with the workpiece, and there is no problem of wear of the processing tool; c. The workpiece is free from stress and is not easily contaminated; d. The laser beam is easy to control and easy to combine with precision machinery, precision measurement technology and electronic computer to achieve high automation of processing and high machining accuracy; Advantages over chemical texturing: a. Alloying elements that are inserted in the near-surface area by laser power are completely molten in the process and change the chemical composition and therefore the properties of the material. Thus, low-cost substrate materials can be alloyed to create surface zones with a high quality. b. the possibility of automation or the reducedgeneration of toxic by products. Advantages over electric discharge texturing: a. Those non-conductive materials can be processed by laser, but cannot with electric discharge b. If laser processing is used, the internal stress of the workpiece will not increase. Applications: a. Laser cladding: The buildup of layers on a substrate material under the utilization of an additive material. b. Repair welding: It is used for high-quality and expensive workpieces in the range of cladding. c. Laser marking: It has great potential concerning resistance of the mark, high-contrast marking, and processing speed. 三、纳米制造部分 1、Summarize the application/impact of photolithography. Photolithography is the most significant fabrication process that has revolutionized modern life. The manufacturing of modern gadgets, such as computers, digital TVs, radios, and cell phones, involves photolithography. At the same time, photolithography is acclicable to lots of materials, such as silicon, silica, copper, etc. 2、Why is there a need to develop non-photolithographic processes? As the feature size gets smaller, the requirement for infrastructure gets prohibitively expensive and it is eventually impractical to continuously utilize photolithography in the fabrication of structures with dimensions less than tens of nanometers. The use of an optical field as the manufacturing field in photolithography has an ultimate limitation in the smallest feature sizes this field can handle and eventually it will be technically impossible to generate structures at nanometer scales. 3、Summarize the different fields used in several soft lithography processes. Fabricate structures of mesoporous silica Functional mesoporous silica-based waveguide shape Hierarchically ordered mesoporous silica generated The fabrication of nanocrystal laser 4、Summarize the applications of soft lithography and imprinting lithography. Processing various materials into functional devices, including inorganic materials and fragile, bioactive materials Generating micro and nano reactors for the synthesis of materials at nanometer sizes 5、What is the self-assembly process? How does it fit into intelligent energy field manufacturing? Self-assembly is defined as the process of generating structures with nanometer dimensions by taking advantage of many different fields, such as the chemical field, biointeraction field, flow field, etc. The future of nano-manufacturing development will focus highly on precision, low cost, adaptability to various applications, and being environmentally friendly. And at that time, we may rely more on self-assembly to make nano-structures, which leads to lower carbon footprint and being more friendly to environment. 英 中 photolithography 光刻技术 fabrication 制造 gadgets 小玩意儿 silicon 硅 silica 二氧化硅 copper 铜 soft lithography 软光刻 imprinting lithography 压印光刻 self-assembly 自组装 参考资料： 1、Intelligent Energy Field Manufacturing: Interdisciplinary Process Innovations","link":"/2019/12/21/%E5%AD%A6%E7%A7%91%E7%AC%94%E8%AE%B0/%E5%85%88%E8%BF%9B%E5%88%B6%E9%80%A0%E7%AC%94%E8%AE%B0/"},{"title":"考研——概率论","text":"概率论一般不会出难题，主要记忆。 第一讲 随机条件与概率 全概率公式 贝叶斯公式 n重伯努利公式 第二讲 一维随机变量及其分布 要明白几大离散型分布的实际情况，八大分布的概率密度和分布函数。 正态分布记得看图。 第三讲 多维随机变量及其分布 联合概率密度和边缘概率密度之间的关系 Z=X+Y型的边缘概率密度求解（公式法，分布函数家法） 全概率公式 第四讲 随机变量的数字特征不难，多背多记，防切比雪夫出题。 第五、六讲 大数定律和中心极限定律&amp;数理统计这一块三大分布写了两遍，第二次写完才大概明白意思。 参考资料：1、张宇–《考研数学基础30讲》及相关视频 2、汤家凤–《概率论》（数理统计部分）","link":"/2020/09/04/%E5%AD%A6%E7%A7%91%E7%AC%94%E8%AE%B0/%E8%80%83%E7%A0%94-%E6%A6%82%E7%8E%87%E8%AE%BA/"},{"title":"考研——线代","text":"线性代数里面方法很重要，要熟知题型和考点。 第一章 行列式 第二章 矩阵线性代数中最重要的一环——鲁迅。 第三章 向量组3、4两章（向量组和方程组）是一体的，内容相同，注意多做题总结规律。 第四章 方程组 第五章 特征值和特征向量5、6两章（特征值和二次型）相关性比较大，第五章可以单独出题，也可以夹杂在二次型里面考。 第六章 二次型牢记常见题目的套路: 将二次型化为规范型和标准型的方法有配方法、正交变换 牢记f正定的充要条件和必要条件 参考资料：1、张宇–《考研数学基础30讲》及相关视频","link":"/2020/08/25/%E5%AD%A6%E7%A7%91%E7%AC%94%E8%AE%B0/%E8%80%83%E7%A0%94-%E7%BA%BF%E4%BB%A3/"},{"title":"机械设计--查询轴承的额定动载荷值","text":"今天写作业，轴承部分需要用到查询6311轴承的额定动载荷值。可是书上没有对应的表格数据，同时我又不想去图书馆借大部头的《机械设计手册》。这就有了这篇笔记，主要记录如何用电脑查取机械设计相关的数据。 一、寻找《手册》电子版最正规的方法当然是寻找《机械设计手册》的电子版了。我在搜索的时候发现了一个神奇的网站，“非标机械设计论坛”，其中有大佬已经发出了机械设计手册的第五版和第六版的pdf，然鹅下载之后我发现版本好像和想象中的有些不一样，并没有我要查的轴承信息。 发现论坛上有人在说这个软件包，我想也不错啊。下载安装完了之后就被这古老的画风感动到了。经查，也确实没有轴承额定载荷的详细信息。 天罗地网终于找到了我要的《手册》，应该是成大先同志编写的大部头，5本一共800多M。 百度网盘： https://pan.baidu.com/s/1qWp25Yk （提取码：r2hk，解压密码： www.jxsjgcs.com） 经查，这个版本的确实没错了！但是，实在是太多了，看到人眼花缭乱！ 二、找企业我去了精工的中国区网站，惊喜地发现真的有轴承型号查询，一边感叹日本人的工匠精神一边输入6311之后，却发现只有内外径之类的少量信息。点击“查看详情”结果是啥都没有。 三、看看有没有专门的网页搜这个的还真的有，而且数据就恰好有额定载荷，（哭）。。。 型号查询网，嗯，很简单直男的名字。查询结果很优秀！","link":"/2019/11/20/%E5%AD%A6%E7%A7%91%E7%AC%94%E8%AE%B0/%E6%9C%BA%E6%A2%B0%E8%AE%BE%E8%AE%A1--%E6%9F%A5%E8%AF%A2%E8%BD%B4%E6%89%BF%E7%9A%84%E9%A2%9D%E5%AE%9A%E5%8A%A8%E8%BD%BD%E8%8D%B7%E5%80%BC/"},{"title":"自控原理复习","text":"还有两天就考试，好耶（哭泣）！开始预习课本了！本篇进行第三章节的重点梳理。第四章第五章来不及写成博客了（继续哭泣）… 第三章 自动控制系统的时域分析3.1 掌握系统稳定性的充要条件，并能根据劳斯判据判定系统的稳定性。（*）1892年李普亚诺夫首先提出了稳定性的严格数学定义，根据稳定性的定义（P62），当系统满足以下条件时，系统稳定，此条件时充要的。$$\\lim_{n \\rightarrow \\infty}C(t)=0$$线性系统稳定的充要条件是：系统特征方程的根（即系统的闭环极点）均为负实数或具有负实部的共轭复数。也就是说，系统的全部闭环极点都在复数平面虚轴的左半部。 劳斯稳定判据：在写成s的多项式形式的标准方程中，实部为正数的根的个数等于劳斯表的第一列元素符号改变的次数。 因此，系统稳定的充要条件是：特征方程的全部系数都是正数，并且劳斯表第一列元素都是正数。 3.2 掌握典型输入信号的时域及频域表达式，并掌握阶跃响应性能指标。（*）1）典型输入信号： 单位阶跃函数 时域表达式：$$l(t)=\\left{\\begin{aligned}1&amp;,t\\ge0\\0&amp;,t&lt;0\\\\end{aligned}\\right.$$拉氏变换：$ L[l(t)]=\\frac{1}{s}$ 频域表达式： 单位斜坡函数 时域表达式：$$r(t)=\\left{\\begin{aligned}t&amp;,t\\ge0\\0&amp;,t&lt;0\\\\end{aligned}\\right.$$ 拉氏变换：$L[t∗l(t)]=\\frac{1}{s^2}$ 频域表达式： 单位抛物线函数（加速度阶跃函数） 时域表达式：$$r(t)=\\left{\\begin{aligned}&amp;\\frac{1}{2}t^2&amp;,t\\ge0\\&amp;0&amp;,t&lt;0\\\\end{aligned}\\right.$$拉氏变换：$L[\\frac{1}{2}t^2∗l(t)]=\\frac{1}{s^3}$ 频域表达式： 2）阶跃响应性能指标： 延迟时间tdtd 指输出第一次达到50%稳态值所需时间上升时间trtr 指输出响应第一次到达稳态值的时间峰值时间tptp 指输出超过稳态值到达第一个峰值cmaxcmax所需要的时间最大超调量σσ% 指输出量的最大值超出稳态值的百分比，即 $$\\sigma=\\frac{c_max-c_\\infty}{c_\\infty}*100$$ 调节时间tsts 当阶跃响应曲线到达并不再超出误差带所需最小时间，一般取5%c∞c∞的误差振荡次数N 在调节时间内响应曲线偏离稳态值的振荡次数稳态误差essess 当时间t趋于无穷大时，系统单位阶跃响应的稳态值与输入量l(t)l(t)之差，即 $$ess=l−c(\\infty)$$ 以上指标中，四个时间反映了系统的快速性，σσ和N反映了平稳性，称为动态性能指标；essess描绘了系统的稳态响应，反映了系统的静态性能，又称为静态性能指标。 3.3 掌握控制系统的动态性能指标求取。重点掌握二阶系统的指标求取，对于高阶系统应掌握主导极点的确定方法。（*）1）一阶系统的动态指标（P73） 可以归纳为几个步骤： 写出闭环传递函数$Φ(s)$，并且与典型形式$Φ(s)=\\frac{K}{Ts+1}$对照写出T和K 求取输出量$c(t)$，$c(t)$是$C(t)$的拉式反变换，$C(t)=L^{−1}(Φ(s)R(s))$ $c(t)$可以分解成两个式子，分别代表调节响应$c_t(t)$和稳态响应$c_{ss}(t)$ 2）二阶系统的动态指标（P75） 典型形式：$Φ(s)=\\frac{K}{T^2S^2+2ξTs+1}$ 若K=1，又可以写为$Φ(s)=\\frac{w_n^2}{S^2+2ξw_ns+w_n^2}$，式中$w_n=\\frac{1}{T}$ 当输入信号是单位阶跃函数的时候，$R(s)=\\frac{1}{s}$，则$$C(s)=Φ((s)R(S)=\\frac{w_n^2}{S^2+2ξw_ns+w_n^2}\\frac{1}{s}=\\frac{1}{s}−\\frac{s+2ξw_n}{S^2+2ξw_ns+w_n^2}=C_{ss}(s)+C_t(s)$$这里面的ξξ和ωnωn被称为二阶系统的特征参数，经过拉式反变换：$$c_{ss}=1;c(t)=L^{-1}(-\\frac{s+2\\xi w_n}{s^2+2\\xi w_n+s^2})$$$c_t(t)$的特征方程为其分母，两个特征根为$$s_{1,2}=−ξω_n±ω_n\\sqrt{ξ^2−1}$$这里面ξ（阻尼系数）的取值不同时间响应曲线有不同的形状： $ξ=0$特征方程有一对共轭虚根（零阻尼）-&gt; 无衰减的周期振荡 $0&lt;ξ&lt;1$ 特征方程有一对共轭复根（欠阻尼）-&gt; 衰减的振荡$ξ=1$ 特征方程有一对相等的负实数根（临界阻尼）-&gt; 单调的衰减过程$ξ&gt;1$ 特征方程有两个不同的负实数根（过阻尼）-&gt; 两个指数衰减状态的叠加 [需要掌握的公式] 欠阻尼状态，最大超调量σ%完全由阻尼系数ξ决定：$σ=exp(−πξ/\\sqrt{1−ξ^2})$ 当ξ比较小时，调节时间：$ts≈\\frac{3}{ξω_n}$（取Δ=0.05） 阻尼角β公式：$β=arccosξ$ 拉氏变换的终值定理：$\\lim_{t \\rightarrow \\infty}f(t)=lim_{s \\rightarrow 0}sF(s)$ 当闭环传递函数的$K≠0$时，需要算出ξξ的值并查图来获得调整时间： [带有零点的二阶系统] 影响：一般来说会是系统响应迅速且具有较大的超调量σσ%。零点与一堆共轭复数在复平面上的相对位置决定了零点对阶跃响应的影响。用α=z/(ξωn)α=z/(ξωn)来量化，αα越小，影响程度越大。 规律：有了零点并不会导致时间常数T0T0，但是会增大阻尼系数ξξ，那么就会影响调节时间和最大超调量两个值。 调节时间：$t_s=(3+ln\\frac{l}{z})\\frac{1}{ξω_n}$ 最大超调量，查图3-28（P90）： 3)高阶系统主导极点的确定方法 闭环主导极点的概念：这一对极点离虚轴最近，并且其他的零极点要么很远要么抵消了。 非主导极点的判定：当引进的实数极点与主导极点的模值之比$α=\\frac{p_3}{ω_n}$大于5时，可以认为时非主导极点，影响可以忽略。 3.4 熟悉系统的稳态误差概念，并要求能够求取给定输入作用下及扰动输入作用下稳态误差。（*）1）稳态误差的定义 从输入端定义为稳定时输入信号和反馈信号之差：$e_{ss}=lim_{t→∞}(r(t)−b(t))$ 从输出端定义为输出量的期望值和实际值之差：$e_{ss}=lim_{t→∞}(c_0(t)−c(t))$ 由第一种定义推导出来，$e_{ss}=lim_{s→0}\\frac{sR(s)}{1+G_K(s)}$ 2）工程上根据积分环节的个数υυ对系统进行分类，分别称为0型、Ⅰ型系统、Ⅱ型系统等 3）例题3-19（P109） 3.5 掌握不同系统型别下，系统的静态位置误差系数KpKp、静态速度误差系数KvKv以及静态加速度误差系数KaKa的求取，以及它们与稳态误差的关系。（*） 单位阶跃函数输入 $K_p$ 与稳态误差的关系$ess=\\frac{1}{K_p}$ 对0型系统，$K_p=1+K_0$；对于非0型系统，$K_p→∞,e_{ss}=0$ 单位斜坡函数输入 $K_v$ 与稳态误差的关系$ess=\\frac{1}{K_v}$ 对0型系统，$K_v=0,e_{ss}→∞$；对于Ⅰ型系统，$K_v=K_0,ess=\\frac{1}{K_0}$；对于Ⅱ型系统，$K_p→∞,e_{ss}=0$ 单位抛物线函数输入$K_a$ 与稳态误差的关系$ess=\\frac{1}{K_a}$ 对0型系统，$K_a=0,e_{ss}→∞$；对于Ⅰ型系统，$K_a=0,e_{ss}=→∞$；对于Ⅱ型系统，$K_a=K_0,ess=\\frac{1}{K_0}$ 表3-6（P105）完美概括： 3.6 了解PID控制器各部分的作用，并能根据实际系统需求选取合适、经济的控制器。PID调节器各部分的作用分别是比例(P)、积分(I)、微分(D)控制算法。 比例，反应系统的基本（当前）偏差，系数大，可以加快调节，减小误差，但过大的比例使系统稳定性下降，甚至造成系统不稳定； 积分，反应系统的累计偏差 ，使系统消除稳态误差，提高无差度，因为有误差，积分调节就进行，直至无误差； 微分，反映系统偏差信号的变化率，具有预见性，能预见偏差变化的趋势，产生超前的控制作用，在偏差还没有形成之前，已被微分调节作用消除，因此可以改善系统的动态性能。但是微分对噪声干扰有放大作用，加强微分对系统抗干扰不利。 参考资料： 1、自动控制原理（第四版，高国燊等人著） 2、PID调节器各部分的作用分别是什么？","link":"/2019/11/16/%E5%AD%A6%E7%A7%91%E7%AC%94%E8%AE%B0/%E8%87%AA%E6%8E%A7%E5%8E%9F%E7%90%86%E5%A4%8D%E4%B9%A0/"},{"title":"自控原理实验（下）","text":"本次实验将要通过根轨迹来分析系统性能。 本篇文章记录自动控制原理的后三个实验，包括“基于MATLAB控制系统的根轨迹及其性能分析”，“基于MATLAB控制系统的Nyquist图及其稳定性分析”和“基于MATLAB控制系统的Bode图及其频域分析”。 $4. 基于MATLAB控制系统的根轨迹及其性能分析1、实验目的（1）熟练掌握使用MATLAB绘制系统零极点图和根轨迹图的方法； （2）学会分析控制系统根轨迹的一般规律。 （3）利用根轨迹图进行系统性能分析。 2、开环闭环传递函数 G(s)称为前向通道传递函数，是输出Xo(s)与偏差E(s)之比； H(s)称为反馈回路传递函数，是反馈信号B(s)与输出Xo(s)之比； 而G(s)*H(s)是被人为定义为系统的开环传递函数Gk(s)，也是反馈信号与偏差之比； 闭环传递函数的定义则为输出与输入之比。 3、根轨迹3.1 概念根轨迹是开环系统某一参数从零变到无穷时，闭环系统特征方程式的根在s平面上变化的轨迹。根轨迹是分析和设计线性定常控制系统的图解方法，使用十分简便，特别在进行多回路系统的分析时，应用根轨迹法比用其他方法更为方便，因此在工程实践中获得了广泛应用。 3.2 根轨迹与系统稳定性1.如果根轨迹全部位于s平面左侧，就表示无论增益怎么改变，特征根全部具有负实部，则系统就是稳定的。 2.如果根轨迹在虚轴上，表示临界稳定，也就是不断振荡。 3.如果根轨迹根轨迹全部都在s右半平面，则表示无论选择什么参数，系统都是不稳定的。 也就是说增益在一定范围内变化时，系统可以保持稳定，但是当增益的变化超过这一阈值时，系统就会变得不稳定，而这一阈值就是出现在根轨迹与虚轴的交点上，在这一点系统临界稳定。最终可由增益的取值范围判断系统的稳定性。 3.3 绘制法则根轨迹的绘制具有以下绘制法则： 法则1.起点和终点 根轨迹的起点和终点。根轨迹起于开环极点（包括无限极点），终于开环零点（包括无限零点）。 法则2.分支数、对称性和连续性 根轨迹的分支数、对称性和连续性。根轨迹的分支数与开环有限零点数m和有限极点数n中的大者相等，它们是连续的并且对称于实轴。 法则3.渐近线 根轨迹的渐近线。当开环n&gt;m时，有n-m条根轨迹分支沿着与实轴交角为$\\varphi_a$、交点为$\\sigma_a$的一组渐近线趋向无穷远处，且有$\\varphi_a=\\frac{(2k+1)\\pi}{n=m}(k=0,1,2,…,n-m-1)$和$\\sigma_a=\\frac{\\sum_{i=1}^{n}p_i-\\sum_{j=1}^{m}}{n-m}$ 法则4.在实轴上的分布 根轨迹在实轴上的分布。实轴上的某一区域，若其右边开环实数零、极点个数之和为奇数，则该区域必是根轨迹。 法则5.分离点与分离角 根轨迹的分离点与分离角。两条或两条以上根轨迹分支在s平面上相遇又立即分开的点，称为根轨迹的分离点，分离点的坐标d是下列方程的解：$$\\sum_{j=1}^m\\frac{1}{d-z_j}=\\sum_{i=1}^m\\frac{1}{d-p_i}$$ 式中，$z_j$为各开环零点的数值；$p_i$为各开环极点的数值；分离角为$(2k+1)\\pi/l$ 法则6.起始角与终止角 根轨迹的起始角与终止角。根轨迹离开开环复数极点处的切线与正实轴的夹角，称为起始角；根轨迹进入开环复数零点处的切线与正实轴的夹角，称为终止角。这些角度都可以由特定关系式求出。 法则7.与虚轴的交点 根轨迹与虚轴的交点。若根轨迹与虚轴相交，则交点上的$K’$值和$\\omega$值可用劳斯判据确定，也可令闭环特征方程中的$s=j\\omega$，然后分别令其实部和虚部为零而求得。 法则8.根之和 根之和。$$\\sum_{i=1}^ns_i=\\sum_{i=1}^np_i$$ 3.4 实验例子 已知系统的开环传递函数为$G_k(s)=\\frac{s^2+5s+5}{s(s+1)(s^2+2s+2)}$，绘制系统的零极点图 1num=[1 5 5];den=[1 3 4 2 0];pzmap(num,den);grid; 2）已知系统的开环传递函数为$G_k(s)=\\frac{k}{s(s+1)(s+2)}$，绘制控制图系统的根轨迹图，并分析根轨迹的一般规律 1num=[1];den=[1 3 2 0];rlocus(num,den);grid 根轨迹的一般规律：[黑人问号.jpg] 3）在实验内容（2）中控制系统的根轨迹上分区段取点，构造闭环系统传递函数，分别绘制其对应的阶跃响应曲线，并比较分析 1k=1;z=[];p=[0 -1 -2];[num,den]=zp2tf(z,p,k);rlocus(num,den);grid[k,r]=rlocfind(num,den)[num,den]=zp2tf(z,r,k);step(num,den) s轴右侧 -&gt; 不稳定状态 s轴左侧的曲线弯头部分，产生一对共轭复根 -&gt; 欠阻尼状态 曲线零点处，产生两个相同的特征根 -&gt; 临界稳定状态 左边线段处，特征根均为负实数 -&gt; 过阻尼状态 参考资料： 1、百度百科：根轨迹 2、开环传递函数与闭环传递函数区别？ $5. 基于MATLAB控制系统的Nyquist图及其稳定性分析1、实验目的（1）熟练掌握使用MATLAB绘制系统Nyquist图的方法； （2）能够分析控制系统Nyquist图的基本规律； （3）加深理解控制系统奈奎斯特稳定性判据的实际应用； （4）学会用奈氏图设计控制系统。 2、概念解释2.1 幅相频率特性曲线以角频率$\\omega$为参变量，当从$\\omega$从$0\\to\\infty$变化时，频率特性构成的向量在复平面上描绘出的曲线称为幅相频率特性曲线，又称为极坐标图，或Nyquist曲线，简称奈氏图。 一般表达形式，其中$A(\\omega)$和$\\varphi(\\omega)$分别代表了系统的幅频特性和相频特性：G(jω)=A(ω)ejφ(ω)=A(ω)cos(φ(ω))+j∗A(ω)sin(φ(ω))G(jω)=A(ω)ejφ(ω)=A(ω)cos(φ(ω))+j∗A(ω)sin(φ(ω)) 2.2 奈奎斯特稳定性判据（又称奈氏判据）奈奎斯特稳定性判据是利用系统开环频率特性来判断闭环系统稳定性的一个判据，便于研究当系统结构参数改变时对系统稳定性的影响。其内容是：反馈控制系统稳定的充分必要条件是当$\\omega$从$-\\infty\\to+\\infty$时，开环系统的奈氏曲线$G_k(j\\omega)$不穿过（-1，j0）点且逆时针包围临界点（-1，j0）的圈数N等于开环传递函数的正实部极点数P。具体地说： ①对于开环稳定的系统，闭环系统稳定的充分必要条件为开环系统的奈氏曲线$G_k(j\\omega)$不包围（-1，j0）点。反之闭环系统不稳定。 ②对于开环不稳定系统，有P个开环极点位于右半s平面，则闭环系统稳定的充分必要条件为当$\\omega$从$-\\infty\\to+\\infty$时，开环系统的奈氏曲线$G_k(j\\omega)$逆时针包围（-1，j0）点P次。 重要公式： N = Z - P \\ 当闭环系统稳定时，Z=0，上式可变为N = - P 3、实验内容1）已知系统的开环传递函数为$G_k(s)=\\frac{10}{s^2+2s+10}$，绘制其Nyquist图 1num=10;den=[1 2 10];nyquist(num,den)grid 2）已知系统的开环传递函数为$G_k(s)=\\frac{0.5}{s^3+2s^2+s+0.5}$，绘制其Nyquist图，并判定系统的稳定性 1% 第一步，绘制系统的Nyquist图，相应的程序为：num=0.5;den=[1 2 1 0.5];nyquist(num,den)grid% 第二步，确定开环极点在右半s平面的个数p,相应的程序为p=[1 2 1 0.5];roots(p) 运行结果：s右半平面有3个开环极点，所以P=3。看图可知，N=0。 所以Z=N+P=0+3=3，闭环系统不稳定。 参考内容： 1、欧拉公式 2、百度百科：奈奎斯特稳定判据 $6. 基于MATLAB控制系统的Bode图及其频域分析1、实验目的（1）熟练掌握运用MATLAB命令绘制控制系统Bode图的方法； （2）了解系统Bode图的一般规律及其频域指标的获取方法； （3）熟练掌握运用Bode图分析控制系统稳定性的方法。 2、相关概念2.1 对数频率特性曲线又称频率特性的对数坐标图或伯德（Bode）图，由对数幅频特性曲线（纵坐标为$10lg|G_k(j\\omega)|$，单位是分贝，dB）和对数相频特性曲线（纵坐标为度，°）组成，两者的横坐标都是角频率$\\omega$，采用$lg(\\omega)$分度。 用对数频率特性曲线表示系统频率特性的优点是： ①幅频特性的乘除运算转变为加减运算； ②对系统作近似分析时，只需画出对数幅频特性曲线的渐近线，大大简化了图形的绘制； ③可以用实验方法将测得的系统（或环节）频率响应的数据画在半对数坐标纸上，根据所做出的曲线，估计被测系统的传递函数。 2.2 对数稳定判据对数频率特性曲线是奈氏判据移植到对数频率坐标的结果。若$G_k(j\\omega)$包围（-1，j0）点，即$G_k(j\\omega)$在点（-1，j0）左边有交点，在Bode图中表现为$L(\\omega)&gt;0$分贝所在的频段范围内，$\\varphi(\\omega)$与-180°线有交点。 对数频率稳定性的判据为：闭环系统稳定的充分必要条件是当$\\omega$从零变化到$+\\infty$时，在开环系统对数幅频特性曲线$L(\\omega)&gt;0$分贝的频段内，相频特性$\\varphi(\\omega)$穿越$(2k+1)\\pi(k=0,\\pm1,\\pm2,…)$的次数N为$\\frac{P}{2}$，其中$N=N_+-N_-$，$N_+$为正穿越次数，$N_-$为负穿越次数，P为开环传递函数的正实部极点数。 2.3 稳定裕度1）相角裕度$\\gamma$ 2）幅值裕度$h_g$ 3）关于相角裕度和增益裕度的几点说明：控制系统的相角裕度和幅值裕度是系统幅相特性曲线对（-1，j0）点靠近程度的度量。因此，这两个裕度可以用来作为设计准则。只用幅值裕度或相角裕度都不足以说明系统的相对稳定性，必须同时给出这两个量。 对于最小相位系统，只有当相角裕度和幅值裕度都是正值时系统才是稳定的。负的裕度表示系统不稳定。为了得到满意的性能，相角裕度应当在30°-60°之间，幅值裕度应大于6dB。","link":"/2019/11/15/%E5%AD%A6%E7%A7%91%E7%AC%94%E8%AE%B0/%E8%87%AA%E6%8E%A7%E5%8E%9F%E7%90%86%E5%AE%9E%E9%AA%8C%EF%BC%88%E4%B8%8B%EF%BC%89/"},{"title":"考研——高数下","text":"高数占整个数学一考研的56%，属于数学一的基本盘。 第11讲 多元函数微分学P157-170，这一讲概念比较多，东西比较杂，但是内容不难，计算量比较大。 第12讲 二重积分二重积分原理上不太难，但是需要掌握几个要点。 几何意义 对称性，其中轮换对称性还比较重要 直角坐标和极坐标的互化 积分次序的变更 用二重积分解决一元积分问题 第13讲 常微分方程这一章要背的好多，主要是各种微分方程的通解和特解。最好把一阶的和二阶的区分开背，这样可能比较简单。计算的时候用到不少常见的积分和微分等式。 第14讲 无穷级数这个很难，需要重点复习。考点有： 正项级数及其敛散性（达朗贝尔和柯西） 交错级数及其敛散性（莱布尼茨判据） 任意项级数及其敛散性 幂级数（阿贝尔和收敛域） 幂级数求和、函数展开为幂级数 经验： 7个常见的重要展开式及收敛域（麦克劳林展开） 调和级数，交错调和级数，p级数等常见级数 不等式公式有一些会用在敛散性证明的构造上 幂级数求和常用逐项求导或逐项积分 第15讲 数一应用题闭关第1天：完成第15讲，主要讲的是数学一应用题，欧拉公式和傅立叶级数。 第17章 多元函数积分学的基本知识这讲也是多元函数微积分的应用题，涉及到空间解几问题。需要背好的有： 空间旋转曲面的求法 空间曲面的切平面和法线 空间曲线的切线和法平面 方向导数与梯度 散度和旋度 附：散度和旋度的物理意义是什么？.pdf 第18章 三重积分+曲线、曲面积分这一讲的概念跟物理结合很紧密。 第一型的曲线、曲面积分都可以看作是求密度为f的曲线、曲面质量，第二型的曲线、曲面积分是矢量性的积分。格林公式有环线的和指向中间的形式，分别从二维向三维推广，就可以得到斯托克斯公式和高斯公式。 格林公式的几何意义.pdf 理解斯托克斯公式.pdf 参考资料：1、张宇–《考研数学基础30讲》及相关视频 2、知乎马同学高赞答案","link":"/2020/08/25/%E5%AD%A6%E7%A7%91%E7%AC%94%E8%AE%B0/%E8%80%83%E7%A0%94-%E9%AB%98%E6%95%B0%E4%B8%8B/"},{"title":"自控原理实验（上）","text":"近期即将迎来自动控制原理的考试，考前要做六个实验，遂写下两篇文章为记。 本篇记录前三个实验，包括“时域分析法”，“Simulink仿真”，“用Matlab实现几种典型信号时间响应”。 $1. 时域分析实验1、实验目的：1、观察单位阶跃信号输入时二阶系统的时间响应，分析ξ、Wn对响应曲线及瞬态响应指标tn tp ts Mp%的影响。 2、了解二阶系统瞬态响应指标的意义其计算。 2、实验内容2.1 将系统的零极点增益模型转换成传递函数模型G(s)=6(s+3)(s+1)(s+2)(s+5)G(s)=6(s+3)(s+1)(s+2)(s+5) 1k=6z=[-3]p=[-1,-2,-5][num,den]=zp2tf(z,p,k); 2.2 对典型二阶系统G(s)=ω2s2+2ξωns+ω2nG(s)=ω2s2+2ξωns+ωn2输入单位阶跃信号1（t）,且wn=1，ξ分别等于-0.1；-0.2；0；0.1；0.5；1；1.5。及ξ=0.5，wn分别等于1; 10; 30; 50的响应曲线。1wn=1kosi=[0 , 0.1 , 0.5 , 1 , 1.5]figure(1)hold onfor kos=kosinum=[ wn ^ 2];den=[1 , 2*kos* wn , wn^ 2];step(num,den)endtitle('Step Response')hold offgridzoom on 3、遇到问题：3.1matlab中，zp2tf()函数作用：将系统函数的零极点形式 (zp) 转化为系统函数一般形式 (tf) 的系数。 在这里2应该代表转换；zp，zero point &amp; pole -&gt; 零极点；tf, transfer function -&gt; 传递函数。 在matlab中，有一个函数tf(?)，是传递函数的意思，一般学自动控制原理的时候经常用，在s域中，比如要输入G（s）=1/（s^2+2s+1），就可以在matlab中输入G=tf（[1],[1 2 1]）。 零极点形式：分子式系数为k，零点从分子产生（z1, z2, …），极点从分母中产生（p1, p2, …）。 举栗：得到了系统函数H(s)的零极点的值，z为零点的值，p为极点的值，k为系数，如图所示，n1为a的值，d1为b的值，这里的n1,d1,z,p均为向量形式。 3.2 matlab中，step()函数官方注释Step response plot of dynamic system; step response data 官方Description step calculates the step response of a dynamic system. For the state-space case, zero initial state is assumed. When it is invoked with no output arguments, this function plots the step response on the screen. 作用：将一个动态系统的阶跃响应绘图 3.3 matlab中，tf()函数官方注释 Transfer function model 官方Description Use tf to create real-valued or complex-valued transfer function models, or to convert dynamic system models to transfer function form. Transfer functions are a frequency-domain representation of linear time-invariant systems. For instance, consider a continuous-time SISO dynamic system represented by the transfer function sys(s) = N(s)/D(s), where s = jw and N(s) and D(s) are called the numerator and denominator polynomials, respectively. The tf model object can represent SISO or MIMO transfer functions in continuous time or discrete time. 4、知识整理4.1 Z变换Z变换（英文：z-transformation）可将时域信号（即：离散时间序列）变换为在复频域的表达式。它在离散时间信号处理中的地位，如同拉普拉斯变换在连续时间信号处理中的地位。离散时间信号的Z变换是分析线性时不变离散时间系统问题的重要工具，在数字信号处理、计算机控制系统等领域有着广泛的应用。 Z变换在离散系统中的地位与作用，类似于连续系统中的拉氏变换 。同时具有许多重要的特性：如线性、时移性、微分性、序列卷积特性和复卷积定理等等。 已有现成的与拉氏变换表类似的Z表。对于一般的信号序列，均可以由表上直接查出其Z变换。相应地，当然也可由信号序列的Z变换查出原信号序列，从而使求取信号序列的Z变换较为简便易行。 4.2 系统函数用单位脉冲响应h(n)可以表示线性时不变离散系统，这时 y（n）=x（n）*h（n） 两边取z变换：**Y(z)=X(z)H(z)**则定义为系统函数。 定义： 系统函数是个具有实系数的复变量S的有理函数，即实有理函数，所以它的极点和零点或者是实数而位于实轴上，或者是成共轭对的复数而位于与实轴对称的位量上。就是说，系统函数的极点和零点的分布必定对实轴成镜像对称。 常用系统：因果系统、稳定系统、因果稳定系统 极点和零点： 系统函数的极点和零点的分布必定对实轴成镜像对称。 系统函数一般有n个有限的极点和m个有限的零点。 如果n&gt;m，则当s为无穷大时。函数值limx→∞H(s)=limx→∞bmsmansnlimx→∞H(s)=limx→∞bmsmansn为零，所以H(s)在无穷大处有一个（n-m）阶的零点，零极点个数都是n个；如果n&lt;m，则当s为无穷大时，函数值limx→∞H(s)=limx→∞bmsmansnlimx→∞H(s)=limx→∞bmsmansn亦为无穷大，所以H(s)在无穷大处有一个（m-n）阶的极点，零极点个数都是m个。 根据函数分子和分母幂次的高低，可以有若干零点在无穷大处，或者若干极点在无穷大处，即从广义上来说，系统函数极点和零点的数目应该相等。(看不懂) 4.3 线性时不变系统两方面，一方面是线性，满足叠加原理；另一方面是时不变特性。 时不变系统的定义： 就是系统的参数不随时间而变化，即不管输入信号作用的时间先后，输出信号响应的形状均相同，仅是从出现的时间不同。 用数学表示为T[x(n)]=y[n]则 T[x(n-n0)]=y[n-n0]，这说明序列x(n)先移位后进行变换与它先进行变换后再移位是等效的。 4.4 单位脉冲响应介绍：单位脉冲响应(Unit impulse response)系统对单位脉冲输入的响应。也称作记忆函数。脉冲响应确定一个线性系统的特性，包含有与频率域中的传输函数相同的信息，而传输函数是脉冲响应的拉普拉斯变换。线性系统的输出由系统的输入与它的脉冲响应的卷积给出。 含义： 单位脉冲响应是指一个无穷大的瞬时冲激，并且由于其在时间轴上的积分为1，而t又趋向于零，所以单位脉冲响应的大小应该是无穷大，但是要知道的是，无穷大量也有大小比较，所以单位脉冲响应可以用一个系数对之进行量度。 场景： 在数字信号处理中，单位脉冲响应代表系统的性质，是描述系统的数学公式，也是系统的数学模型。例如：当系统的初始状态为零时，这时给系统输入一个单位脉冲序列x(n)=δ(n)，则系统的输出称为单位脉冲响应，简称脉冲响应，用符号h(n)表示。δ(n)={1(当n=0时)0(当n≠0时)δ(n)={1(当n=0时)0(当n≠0时) 参考资料： 1、[n1,d1]=zp2tf(z,p,k)在matlab中什么意思 2、matlab里面的tf函数是什么怎么用 3、MATLAB中的step()函数 4、百度百科：Z变换 5、百度文库：第六章 系统函数3-4 6、百度百科： 线性时不变系统 7、百度百科：单位脉冲响应 $2. Simulink仿真实验内容：用Matlab仿真（simulink）图示系统输入单位阶跃信号1(t)的响应，分析响应曲线的稳态响应Xoss(t),振荡频率wd(rad/s)最大超调量Mp,峰值时间tp,进入稳态值+5%误差带的调整时间ts。 实践过程1、进入matlab的simulink进行控件的排布和拖放 2、调整时间3、得出结果图参考资料： 1、MATLAB使用Simulink 进行建模与仿真方法 $3. 用Matlab实现几种典型信号时间响应1、实验内容掌握在matlab环境下建立控制系统模型的方法，并学会调用相应的函数实现单位脉冲信号，单位阶跃信号和单位斜坡信号的响应； 2、典型信号时间响应2.1 单位阶跃响应 单位阶跃函数 单位阶跃函数（Unit Step Function）属于典型输入信号，是一种狄利克雷函数，其形式如下：u(x)={0,t&lt;01,t&gt;0u(x)={0,t&lt;01,t&gt;0很明显的一点是，单位阶跃函数在t=0这一点是不连续的。 零状态响应 所谓零状态响应是指系统在接收到指定输入之前处于初始状态，即保证系统是完全因为指定输入（在此为单位阶跃输入）而产生的响应变化。 单位阶跃响应 单位阶跃响应，就是指系统在接收到单位阶跃函数输入后产生的零状态响应。 作用和意义 a) 系统动态性能分析 动态性能是系统性能的一个十分重要的指标，通常用阶跃信号作用来测定系统的动态性能。 一般认为，阶跃信号对于系统来说是十分严峻的工作状态，因为阶跃信号中存在跃断点（不连续点）。 针对零初始状态系统在单位阶跃输入下的响应情况，定义了一系列动态性能指标，用以评判系统的动态性能，如超调量、衰减比、上升时间、调节时间、峰值时间等等。 b) 建立系统响应模型 对于典型的输入信号，如冲激信号、阶跃信号、斜坡信号等，都建立有响应模型（在此即单位阶跃响应模型）。根据模型，可以快速判断出实际系统的动态性能指标参数，只需要代入实际系统的相关测量参数，就可以定量分析其性能指标。 2.2 单位脉冲响应 单位脉冲函数 单位脉冲序列δ(n)的数学定义是δ={0t≠0∞t=0δ={0t≠0∞t=0而脉冲的面积，即冲量为单位1S=∫+∞−∞δ(t)dt=1S=∫−∞+∞δ(t)dt=1 脉冲响应函数 在信号与系统或电路理论等学科中，冲激响应(或叫脉冲响应)一般是指系统在输入为单位冲激函数时的输出（响应）。对于连续时间系统来说，冲激响应一般用函数h(t)来表示。对于无随机噪声的确定性线性系统，当输入信号为一脉冲函数 δ（t） 时，系统的输出响应 h（t）称为脉冲响应函数。 脉冲响应函数可作为系统特性的时域描述。 至此，系统特性在时域可以用h(t)来描述，在频域可以用H(ω)来描述，在复数域可以用H(s) 来描述。三者的关系也是一一对应的。 对于任意的输入 u（t）， 线性系统的输出 y（t）表示为脉冲响应函数与输入的卷积， 即如果系统是物理可实现的,那么输入开始之前，输出为0，即当 τ&lt;0时 h(τ)=0，这里τ 是积分变量。 卷积 简单定义：卷积是分析数学中一种重要的运算。 设:f(x),g(x)是R1上的两个可积函数，作积分：∫+∞−∞f(τ)g(x−τ)dt∫−∞+∞f(τ)g(x−τ)dt可以证明，关于几乎所有的实数x，上述积分是存在的。这样，随着x的不同取值，这个积分就定义了一个新函数h(x)，称为函数f与g的卷积，记为h(x)=(f\\g)(x)*。 单位脉冲响应 单位脉冲响应，就是指系统在接收到单位脉冲函数输入后产生的零状态响应。 2.3 单位斜坡响应 斜坡函数 斜坡函数是一元实函数，因其图像像斜坡而得名。斜坡函数在负半轴函数值为零，正半轴为形如y=At的正比例函数。A=1时，称为单位斜坡函数。斜坡函数是系统动力学中经常用来研究系统模型及其反馈系统的有关信息的测试函数。 其函数表达式为：r(t)=max(0,t)r(t)=max(0,t) 单位斜坡响应 单位斜坡响应，就是指系统在接收到单位斜坡函数输入后产生的零状态响应。 3、问题Q：Matlab中没有斜坡响应信号对应的函数，为什么能用阶跃信号来求解？ A：因为斜坡响应信号的一阶导数就是阶跃信号，四种典型信号的关系如下： 参考资料： 1、百度百科：单位阶跃响应 2、自动控制原理（第四版，高国燊等人著） 3、单位阶跃响应单位斜坡响应 4、[小技巧]让Hexo在使用Mathjax时支持多行公式","link":"/2019/11/09/%E5%AD%A6%E7%A7%91%E7%AC%94%E8%AE%B0/%E8%87%AA%E6%8E%A7%E5%8E%9F%E7%90%86%E5%AE%9E%E9%AA%8C%EF%BC%88%E4%B8%8A%EF%BC%89/"},{"title":"Python数据库","text":"很多时候我们希望使用数据库，而不是把数据写在文件里面。本篇文章讨论如何在Python中调用数据库。 数据存储的三种方法: 方法 优点 缺点 把数据存储到内存中 使用方便 程序关闭的时候,内存被释放,数据随之消失 把数据写入到文件中 数据是永久性的,不易丢失 需要经常打开关闭文件,操作比较麻烦 把数据存储到数据库中 永久存储,操作方便 学习难度较大 数据库按照规模大小分为四种: 类别 举例 大型数据库 oracle 中型数据库 Sqlserver 小型数据库 mySQL 微型数据库 sqlite 本文调用的是Python自带的sqlite数据库。 1、调用库 1import sqlite3 # 导入sqlit3库 2、创建数据库和表 123456789# 连接到一个数据库名为 data_base_name 的数据库,如果存在则直接连接,如果不存在则创建data_base=sqlite3.connect('data_base_name')# 设置数据库光标,你之后所有对数据库进行的操作都是通过光标来执行的cursor=data_base.cursor()# 创建一个表名为 table_name 的数据库表,如果这个表不存在的话# 后面括号里面的内容为这个表的属性,属性与属性之间用 , 隔开,属性名与属性类型之间用 空格 隔开,如果不写类型的话,默认 为text类型cursor.execute('create table if not exists table_name(name text,age int,info text)')# 数据库的提交,对数据进行增删改后都需要进行数据库的提交data_base.commit() 3、查询符合条件的数据 123cursor.execute('select * from table_name')result=cursor.fetchall()print(result) 4、增加数据 12cursor.execute('insert into table_name (name,age,info) VALUES (\"python\",29,\"最接近人工智能的计算机语言\")')data_base.commit() 5、删除数据 12cursor.execute('DELETE FROM table_name WHERE name=\"C++\"')data_base.commit() 6、修改数据 123cursor.execute('update table_name set name=\"C++\",age=33 WHERE name=\"python\"')cursor.execute('update table_name set name=\"C++\",age=33 WHERE age=29')data_base.commit() 参考文献： 1、Python3之数据库(以SQLite为例)：https://blog.csdn.net/qq_41646358/article/details/81279548 2、Github代码：https://github.com/Cytor/bilibili/blob/master/python/database.ipynb","link":"/2019/12/31/%E8%87%AA%E5%AD%A6%E6%88%90%E6%89%8D/Python%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"title":"Windows下安装PHP","text":"PHP即“超文本预处理器”，是一种通用开源脚本语言。PHP是在服务器端执行的脚本语言，与C语言类似，是常用的网站编程语言。PHP独特的语法混合了C、Java、Perl以及 PHP 自创的语法。利于学习，使用广泛，主要适用于Web开发领域。 引言：鲁迅先生说过，”PHP是最好的语言！“。我倒要来看看PHP哪里好了。 然而在我搜资料的时候，我的沙雕舍友问我为什么要搜PHP，我问他有什么问题，他却反问我为什么要php。 Windows安装一、下载Windows下特有的PHP集成工具WampServer。 到WampServer的官网下载最新版本的wanpserver：http://www.wampserver.com/en/#download-wrapper，然后进行安装。 安装完成之后启动，在浏览器里面输入localhost，应该是如下界面。 二、修改php文件的访问路径 打开httpd.conf， 寻找“DocumentRoot”，把后面的值改成我们实际网站需要的路径（修改默认路径地址） 寻找“&lt;Directory “c:/wamp/www/“&gt;”，同样把后面的值改成我们网站存放的实际地址（修改默认权限路径地址） 访问home.php网址： 拓展阅读： 1、MySql数据库是默认没有密码的，需要配置 2、后期Apache也可能需要微调配置 参考资料： 1、windows环境下wampserver安装及配置详细教程：https://jingyan.baidu.com/article/c74d6000bb70110f6a595d8d.html 2、如何修改WAMPServer默认的网站路径地址：https://jingyan.baidu.com/article/ad310e80b7dd801848f49e63.html","link":"/2019/12/31/%E8%87%AA%E5%AD%A6%E6%88%90%E6%89%8D/windows%E4%B8%8B%E5%AE%89%E8%A3%85php/"},{"title":"单片机--点亮数码管","text":"经过几个晚上的初步学习，我渐渐结合起来一年前学习的微机原理的一些知识。虽然不一定能搞懂，但是现在确实是通过看原理图、看引脚，逐渐掌握了一点东西。本篇记录在点亮单片机数码管中遇到的问题。 1、动态数码管 原理：动态显示的特点是将所有数码管的段选线并联在一起，由位选线控制是哪一位数码管有效。选亮数码管采用动态扫描显示。所谓动态扫描显示即轮流向各位数码管送出字形码和相应的位选，利用发光管的余辉和人眼视觉暂留作用，使人的感觉好像各位数码管同时都在显示。动态显示的亮度比静态显示要差一些，所以在选择限流电阻时应略小于静态显示电路中的。 位选就是数码管位置（亮灭）的选择；段选就是数码管笔段（亮灭）的选择。 共阳和共阴： 简单来讲，共阴数码管就是把com端接地，其他要点亮的某段就接高电平；共阳数码管，就把com接高电平，其他需要点亮的某段就接地。 LED代码表 这个表很有用，编程的时候需要对照着它来摘取段选码。需要注意的是，段选码是十六进制的，因此编程时需要写成0x3F类似的格式。 引脚图： 当我们需要从头开始开发的时候，我们需要一个引脚图，如下所示。 段选信号：单片机的P00-P07这8个IO口控制的是数码管的段选信号，因此所有数码管的段选都是一样的。 位选信号：上面COM口连接的是非常重要的位选信号，为了节约IO口，单片机会通过38译码器来转换，通过查阅74HC138译码器得知对应的IO口为P22/P23/P24。 2、程序实现123typedef unsigned char u8;u8 code smgduan[16]={0x3f,0x06,0x5b,0x4f,0x66,0x6d,0x7d,0x07, 0x7f,0x6f,0x77,0x7c,0x39,0x5e,0x79,0x71};//共阴 code的作用：code的作用是告诉单片机，定义的数据要放在ROM（程序存储区）里面，写入后就不能再更改。因为C语言中没办法详细描述存入的是ROM还是RAM（寄存器），所以在软件中添加了这一个语句起到代替汇编指令的作用，对应的还有data是存入RAM的意思。 123456789101112131415161718192021void digdisplay()//全部点亮，一次{ u8 i; for(i=0;i&lt;8;i++) { switch(i)//位选操作 { case 0: LSA=0;LSB=0;LSC=0;break; case 1: LSA=1;LSB=0;LSC=0;break; case 2: LSA=0;LSB=1;LSC=0;break; case 3: LSA=1;LSB=1;LSC=0;break; case 4: LSA=0;LSB=0;LSC=1;break; case 5: LSA=1;LSB=0;LSC=1;break; case 6: LSA=0;LSB=1;LSC=1;break; case 7: LSA=1;LSB=1;LSC=1;break; } P0=smgduan[i];//段选操作 delay(100);//太小会来不及清零，混合或相同；太大会不连续； P0=0x00;//归零，消影 } } 要注意delay的大小，如果delay太大会造成类似于流水灯的效果。 P0=0x00这句经过实测没有影响。 参考资料： 1、数码管的段选和位选是什么意思? https://www.uyuyao.com/zuoye/5576154 2、数码管共阳和共阴是什么意思？https://www.zhihu.com/question/39882534 3、C语言中的“code”是什么意思啊？https://zhidao.baidu.com/question/106734427.html","link":"/2020/03/04/%E8%87%AA%E5%AD%A6%E6%88%90%E6%89%8D/%E5%8D%95%E7%89%87%E6%9C%BA--%E7%82%B9%E4%BA%AE%E6%95%B0%E7%A0%81%E7%AE%A1/"},{"title":"记C#窗体写作中遇到的一些问题","text":"最近帮老师写一个窗体应用，逻辑并不复杂。话说原来是有一个的，代码全套，可惜是我没有一丁点了解的java，于是用C#重构一个。 上一次使用C#的时候还是一年之前，当我把VSCode安装回来的时候盯着屏幕发现：实在是啥也想不起来了。于是有了这一篇笔记，记录我这次恢复记忆中遇到的问题，为下次失忆做准备！ Q1：窗口跳转 首先要有两个窗口，如果已经有了一个，就在资源管理器的项目条目上新建一个C#项。图片示意如下👇 选择C#窗体 一般来说窗口跳转都是由按钮Button出发的，拖放一个Button到窗体上，然后双击Button在Button两个花括弧中加入下面的代码。 123456Form2 f1 = new Form2();//基于刚刚创建的窗体的Name属性，如果Name改为了Step2，那么这里面的两个Form2也要改为Step2f1.Owner = this;this.Hide();f1.ShowDialog();Application.ExitThread(); Q2：窗口居中 双击窗体进入.cs文件，在Public+窗体的Name函数中填入下面代码： 1this.StartPosition = FormStartPosition.CenterScreen;//从屏幕正中间开始 效果类似于👇 Q3：Label文字靠右显示 在Label的属性中找到TextAlign这个属性左图现在是MiddleCenter，将它切换为MiddleRight。 效果如右下图👇 Q4：插入表格（待解决） 有问题，好像要用到数据库，先占个坑在这里，以后来填。 寻找DataGridView控件，拖入窗体，然后找到一个“播放按钮”，点击“编辑列” – “添加…”，然后就可以添加列的名称。 参考资料： 1、C# winForm 窗口跳转后关闭上一个窗口的方法 2、C# 实现登录并跳转界面 3、C#.NET常见问题(FAQ)-如何让文本框textbox内容靠右显示","link":"/2019/12/02/%E8%87%AA%E5%AD%A6%E6%88%90%E6%89%8D/%E8%AE%B0%E7%AA%97%E4%BD%93%E5%86%99%E4%BD%9C%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/"},{"title":"deepin上安装安卓虚拟机","text":"腾讯对于linux的适配是很差的，我想要在deepin上面使用腾讯会议，可是目前没有发现wine版和linux版，但我还想要……所以还是装个安卓虚拟机吧。 **[补充]**事实证明我想多了，虽然同为android，但大部分软件都是在arm平台上运行的，换成x86平台就不一定跑的了了，例如腾讯会议。/(ㄒoㄒ)/~~ 讲真，在这之前我从来不知道安卓还有x86的版本（尽管它一直处于更新状态）。 1、安装Vmware主要步骤如下，具体操作略 应用市场下载Vmware-Install 安装 2、下载最新的android x86 从fosshub下载（首选） fosshub的Android X86地址：https://www.fosshub.com/Android-x86.html 其中，9.0-r2版本64位的ISO文件下载地址如下：https://www.fosshub.com/Android-x86.html?dwl=android-x86_64-9.0-r2.iso 从android x86中文站下载 android x86中文站的网址：http://www.x86android.com/ 其中，9.0-r2版本64位的ISO文件下载地址如下：http://down.kejianjidi.com/x86_9.0_r2/android-x86_64-9.0-r2.iso 但是，据站长的说法，服务器的带宽很小，属于不到1M/s的小水管。大家一起下载的话，速度非常慢（实测）。 3、安装android x86虚拟机主要步骤有： 命名、选择类型 分配内存 创建虚拟硬盘、分配空间 选择虚拟光盘文件 启动、修改grub 启动、正常配置 详细图文教程参考资料1：VMware 14 安装 Android x86 7.1 rc1 参考资料： 1、VMware 14 安装 Android x86 7.1 rc1 2、安卓X86中文站 3、fosshub下载站","link":"/2020/04/08/%E5%B0%8F%E6%8A%80%E5%B7%A7/deepin%E4%B8%8A%E5%AE%89%E8%A3%85%E5%AE%89%E5%8D%93%E8%99%9A%E6%8B%9F%E6%9C%BA/"},{"title":"初识单片机--点亮led","text":"淘宝买了一个51单片机，今天到货开始学习。本专题将记录在学习过程中遇到的问题，本篇记录单片机的初次上手中遇到的驱动问题和烧录问题。 1、单片机品牌型号品牌：普中 型号：STC89C52 2、Windows10下烧写 安装CH340驱动 CH340/CH341驱动适用于win7、win8 64位操作系统，安装后就可以进行各种参数操作了，适用于WINDOWS 98/ME/2000/XP/Vista/Linux等操作系统。CH340/CH341驱动可以用于usb转串口操作，转换后可以与各类串口监控软件和调试工具配合使用。 下载链接：https://pan.baidu.com/s/1i4esgIh 下载STC-ISP烧写程序 淘宝客服发给我的普中的烧写程序每次都超时，无法真正写入到单片机里面。搜索了大量相关问题之后，有人推荐使用STC-ISP原厂的烧写程序，果然解决了问题。 下载链接：http://www.stcisp.com/_download_stcisp_new.html","link":"/2020/03/01/%E8%87%AA%E5%AD%A6%E6%88%90%E6%89%8D/%E5%88%9D%E8%AF%86%E5%8D%95%E7%89%87%E6%9C%BA--%E7%82%B9%E4%BA%AEled/"},{"title":"deepin上软件推荐","text":"一开始是因为win10专业版过期了，也不想在用盗版的路上越走越远，所以给电脑重置了deepin系统，截止到今天用了将近二十天了。虽然生态还是比不上windows10，但基本日常软件都有linux版或者替代品，以此篇做总结。 一、办公软件1、WPS全套 – 代替MSOffice金山公司专门为linux开发，系统自带，包括word/ppt/excel/pdf四个组件。 与Windows版本的基本一致，有些许差别，比如没有划词翻译等。 一般办公使用完全够了。 2、GIMP – 代替PhotoShop应用市场有，与Windows的PS版本对应，是开源的。布局、功能与PS基本一致，很容易上手。虽然有大神做出了PS的wine版，然而终究不如一键安装的GIMP方便。 3、雷鸟邮件Thunderbird 是一款免费的电子邮件应用程序，是Mozilla公司发布的开源邮件客户端。 软件配置简单，定制自由—还附有强大功能（反垃圾、反钓鱼等）！虽然界面有些简陋，但是可以自己换外观。 二、截图录屏等1、自带截图区域截图快捷键：Ctrl+Alt+A 全屏截图快捷键：PrtSC键 2、自带录屏可以选择保存为mp4还是gif格式，缺点是不能录入声音 3、Kazam小巧方便，功能强大。 可以区域录制视频，可以录入声音，可以录制中暂停。 4、OneShot Vedio Editor视频剪辑工具，应用市场有下载。大概类似于Pr，但是我不会用。 三、即时通讯1、QQ（wine版）应用市场可以下载，由于是wine版，所以运行起来比较慢。 有一个bug：聊天使用截图的时候双击无法放到聊天窗口，要先保存再手动发图。 2、微信应用市场下载，完美支持。 3、TIM应用市场下载量第一 四、远程控制1、Teamviewer应用市场下载，远程控制神器。 2、RemminaRemmina是一个用GTK +编写的远程桌面客户端，旨在对需要在大型显示器或小型上网本前使用大量远程计算机的系统管理员和旅行者有用。 Remmina在集成且一致的用户界面中支持多种网络协议。 目前，RDP，VNC，SPICE，NX，XDMCP，SSH和EXEC受支持.Remmina是一个用GTK +编写的远程桌面客户端，旨在对需要在其中的许多远程计算机上工作的系统管理员和旅行者有用 大型显示器或小型上网本。 Remmina在集成且一致的用户界面中支持多种网络协议。 当前支持RDP，VNC，SPICE，NX，XDMCP，SSH和EXEC。 五、下载1、百度网盘应用市场有一个wine版，现在官方出了linux版。好像不怎么限速，很爽。 2、迅雷迅雷是迅雷公司开发的一款基于多资源超线程技术的下载软件，作为“宽带时期的下载工具”，迅雷针对宽带用户做了优化，并同时推出了“智能下载”的服务。迅雷利用多资源超线程技术基于网格原理，能将网络上存在的服务器和计算机资源进行整合，构成迅雷网络，通过迅雷网络各种数据文件能够传递。多资源超线程技术还具有互联网下载负载均衡功能，在不降低用户体验的前提下，迅雷网络可以对服务器资源进行均衡。","link":"/2019/10/22/%E5%B0%8F%E6%8A%80%E5%B7%A7/deepin%E4%B8%8A%E8%BD%AF%E4%BB%B6%E6%8E%A8%E8%8D%90/"},{"title":"linux解决ssh关闭之后程序终止问题","text":"今天用ssh连接安卓手机上运行的linux deploy，本来运行了一个python脚本，结果一把ssh窗口关掉后台就停止运行了。经过百度，使用nohup命令。 nohup 是 no hang up 的缩写，就是不挂断的意思。 nohup 命令运行由 Command参数和任何相关的 Arg参数指定的命令，忽略所有挂断（SIGHUP）信号。在注销后使用 nohup 命令运行后台中的程序。要运行后台中的 nohup 命令，添加 &amp; （ 表示“and”的符号）到命令的尾部。 用途：LINUX命令用法，不挂断地运行命令。 在命令行输入以下指令就好了： 1sudo nohup python3 main.py &gt;&gt;/home/cytor/main.out 2&gt;&amp;1 &amp; 其中 ‘/home/cytor/main.out’ 指定了输出内容保存的位置和名称。 而0，1，2则代表不同的输出格式： 0 – stdin (standard input)， 1 – stdout (standard output)， 2 – stderr (standard error) ； 2&gt;&amp;1是将标准错误（2）重定向到标准输出（&amp;1），标准输出（&amp;1）再被重定向输入到myout.file文件中。 参考资料： 1、nohup 详解 2、nohup百度百科","link":"/2019/11/07/%E5%B0%8F%E6%8A%80%E5%B7%A7/linux%E8%A7%A3%E5%86%B3ssh%E5%85%B3%E9%97%AD%E4%B9%8B%E5%90%8E%E7%A8%8B%E5%BA%8F%E7%BB%88%E6%AD%A2%E9%97%AE%E9%A2%98/"},{"title":"deepin硬盘权限问题","text":"今天第一次把deepin做在了固态盘上面，速度快很多，同时带来这个小问题。 社区已经有人提问过了，https://bbs.deepin.org/forum.php?mod=viewthread&amp;tid=173682&amp;extra= 此处进行归纳和搬运： 先用文件管理器进入硬盘目录，按下ctrl+L得到其挂载的目录 执行下面的命令 12sudo setfacl -m \"g:sudo:rwx\" \"复制的路径\"sudo setfacl -d -m \"g:sudo:rwx\" \"复制的路径\"","link":"/2020/06/04/%E5%B0%8F%E6%8A%80%E5%B7%A7/deepin%E7%A1%AC%E7%9B%98%E6%9D%83%E9%99%90%E9%97%AE%E9%A2%98/"},{"title":"pip换国内镜像源","text":"pip国内的一些镜像 阿里云 https://mirrors.aliyun.com/pypi/simple/ 中国科技大学 https://pypi.mirrors.ustc.edu.cn/simple/ 豆瓣(douban) http://pypi.douban.com/simple/ 清华大学 https://pypi.tuna.tsinghua.edu.cn/simple/ 中国科学技术大学 http://pypi.mirrors.ustc.edu.cn/simple/ 以清华镜像为例，食用方法如下。 临时使用1pip install -i https://pypi.tuna.tsinghua.edu.cn/simple some-package 注意，simple 不能少, 是 https 而不是 http 设为默认升级 pip 到最新的版本 (&gt;=10.0.0) 后进行配置： 12pip install pip -Upip config set global.index-url https://pypi.tuna.tsinghua.edu.cn/simple 如果您到 pip 默认源的网络连接较差，临时使用本镜像站来升级 pip： 1pip install -i https://pypi.tuna.tsinghua.edu.cn/simple pip -U 参考资料： 1、清华大学：pypi 镜像使用帮助 2、更换pip源到国内镜像","link":"/2019/12/26/%E5%B0%8F%E6%8A%80%E5%B7%A7/pip%E6%8D%A2%E5%9B%BD%E5%86%85%E9%95%9C%E5%83%8F%E6%BA%90/"},{"title":"如何注册一个coding个人版账户","text":"网友都说代码托管github，码云（gitee），码市（coding）这三个比较好，我已经有了前面两个，最近心血来潮想要注册一个coding账户，却遇到了困难。 首先我是直接去了coding的官网，发现右上角有“个人版登录”、“登录”、“注册”三个按钮，我眉头一皱发现事情并没有那么简单。作为一穷二白的非典型性程序员肯定是从“个人版登录”进去再找注册按钮啦。果然不出我所料，“个人版登录”里面确实有一个“注册”按钮，可是当我点击注册的时候，却出现了如下画面！ 我：？？？？？？？？？？ 我是要注册个人账号欸，怎么又给我导向了团队账号？经过实测发现这个页面和官网右上角的注册页面是一样的！ 解决办法： 1、去腾讯云开发者平台官网注册一个账号，我之前注册过腾讯云了，所以很简单地就好了。 2、账号注册好了之后，修改账户配置。首先设置密码，然后添加邮箱，最后修改用户名。比如我gitHub和gitee都是用的cytor为名字，那么这里我就将用户名改为cytor以便于和其他的平台一致。 3、接下来，可以进入到coding官网的个人版登录页面登陆啦。值得一提的是coding的网页交互做的和github以及gitee有区别，后两者基本相同，而coding给人的感觉是独具一格，用了就回不去了。 个人感觉 和github差不多，无限项目、无限容量，git单仓库2G，仓库总共100G，很nice了 国内组织，还是很照顾国内用户网速的，在有限的测试里面基本秒开！ coding-page服务全部给https解析，而且自动部署（码云免费版要手动） coding的个人版配置如下，来源：官网 - 定价。 资源配额 成员数 ≤ 5 人 不限 不限 项目数 不限 不限 不限 总存储容量 不限 不限 不限","link":"/2019/11/18/%E5%B0%8F%E6%8A%80%E5%B7%A7/%E5%A6%82%E4%BD%95%E6%B3%A8%E5%86%8C%E4%B8%80%E4%B8%AAcoding%E4%B8%AA%E4%BA%BA%E7%89%88%E8%B4%A6%E6%88%B7/"},{"title":"使用VM虚拟机安装运行Deepin","text":"兜兜转转，又回到了纯Win10的系统下。然而确实是好久没见到deepin了，因此甚是想念。遂尝试了VM虚拟机。分享我的经验，以下。 1、安装VM WorkStation不必多言，直接上安装教程：https://mp.weixin.qq.com/s/Rdj5AA7aVOzFDMnXeousWg 2、下载deepin的ISO包搜索deepin，找到“最新版本”。 选择“ISO仓库” 进入之后，选择一个离自己近一点的仓库，一般速度能够达到10+（Mb/s）。 3、安装deepin打开VM Workstation，点击“创建新的虚拟机”，然后按照提示进行操作即可。 4、享受linux的美","link":"/2020/02/10/%E5%B0%8F%E6%8A%80%E5%B7%A7/%E4%BD%BF%E7%94%A8VM%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85%E8%BF%90%E8%A1%8CDeepin/"},{"title":"解决deepin下百度网盘一直缓冲的问题","text":"百度网盘推出了linux版本，我在官网下载安装之后在deepin上面完美运行，美滋滋… 然而好景不长，当我关掉之后再次打开时，百度网盘就陷入了一直缓冲的状态。如封面图。 亲测：当出现如下情况时，打开命令终端输入以下命令即可 1sudo rm -rf ~/baidunetdisk 将baidunetdisk这个文件夹移除以后又可以正常登录了。 参考路径： 1、百度网盘(Linux)版本最近突然打不开了…【已解决】","link":"/2019/10/22/%E5%B0%8F%E6%8A%80%E5%B7%A7/%E8%A7%A3%E5%86%B3deepin%E4%B8%8B%E7%99%BE%E5%BA%A6%E7%BD%91%E7%9B%98%E4%B8%80%E7%9B%B4%E7%BC%93%E5%86%B2%E7%9A%84%E9%97%AE%E9%A2%98/"},{"title":"局域网下全平台传输利器","text":"对于我们这种一会儿用Android，一会儿用Windows，偶尔用用Linux和iOS的肥宅来说，一个真正的跨平台文件传输软件可以解决一些让我们我们很烦躁的问题。 Feem——全平台文件传输软件 优点 缺点 全平台 仅局域网传输 易用、速度快 免费版有广告 免费版无限制 官网被墙 特点： 自动配对连接 / 不需注册登录帐号 局域网传输 / 速度飞快而且更安全 WiFi 热点直连 (离线传输文件 / 无需路由器) 支持文字传输 全平台支持 / 跨设备双向互传 WebShare 网页文件共享，无需安装客户端 下载链接： 1、蓝奏云：https://wws.lanzous.com/iUSHDedkfyb 2、博客站内下载： 安卓：Feem.apk Windows端：Feem_v4.3.0_beta_Windows_Installer.exe Linux端：Feem_v4.3.0_For_Linux.AppImage 参考资料： 1、Feem官方网站：https://www.feem.io/ 2、异次元推荐文章（含下载链接）：https://www.iplaysoft.com/feem.html","link":"/2020/07/05/%E5%B0%8F%E6%8A%80%E5%B7%A7/%E5%B1%80%E5%9F%9F%E7%BD%91%E4%B8%8B%E5%85%A8%E5%B9%B3%E5%8F%B0%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93%E5%88%A9%E5%99%A8/"},{"title":"电脑驱动安装","text":"电脑驱动有手动更新和自动更新两种方法，自动更新就是安装驱动精灵或者360等，本文介绍手动更新。 1.左键单击“我的电脑”（计算机），选择管理，右键单击。 2.选择“设备管理器”。 3.找到你需要更新的驱动，右键单击，选择更新驱动程序就可以了。 扩展资料 驱动程序即添加到操作系统中的一小块代码，其中包含有关硬件设备的信息。有了此信息，计算机就可以与设备进行通信。驱动程序是硬件厂商根据操作系统编写的配置文件，可以说没有驱动程序，计算机中的硬件就无法工作。 参考资料： 1、百度百科-驱动：https://baike.baidu.com/item/驱动/2765136 2、百度知道：https://zhidao.baidu.com/question/1180615761717135739.html","link":"/2020/01/16/%E5%B0%8F%E6%8A%80%E5%B7%A7/%E7%94%B5%E8%84%91%E9%A9%B1%E5%8A%A8%E5%AE%89%E8%A3%85/"},{"title":"解决deepin-qq/tim无法显示头像和图片的问题","text":"之前我一直以为deepin里面的TIM和QQ都是不怎么能重度使用的那种，因为TIM上面的qq头像总是long long ago的久远记忆，这严重影响了使用体验。直到我上网查询后,…. 图片和头像无法显示的原因是打开了ipv6，关掉就好了。关掉ipv6之后几乎所有的wine应用的图片显示都会变正常。 以下方法应该用一个就可以了，如果不可以可以三个全部使用后重启。 1、方法一123sudo sysctl -w net.ipv6.conf.all.disable_ipv6=1sudo sysctl -w net.ipv6.conf.default.disable_ipv6=1sudo sysctl -w net.ipv6.conf.lo.disable_ipv6=1 2、方法二按下ctrl+alt+T，打开终端 1sudo gedit /etc/sysctl.conf 在文件的最后追加这样几行（关闭ipv6）： 1234# IPv6 disablednet.ipv6.conf.all.disable_ipv6 =1net.ipv6.conf.default.disable_ipv6 =1net.ipv6.conf.lo.disable_ipv6 =1 保存退出，清除缓存 1sudo rm -rf ~/.deepinwine/Deepin-QQ 当然如果你安装的是其他容器，比如Tim，Wechat，替换上面的QQ就好。 然后打开QQ，登录的时候头像显示为默认头像，登录完毕正式上线就是最新头像了！浏览聊天记录，问题解决。 3、方法三 编辑 /etc/default/grub 1sudo vim /etc/default/grub 将 1GRUB_CMDLINE_LINUX_DEFAULT=&quot;spalsh quiet &quot; 修改为 1GRUB_CMDLINE_LINUX_DEFAULT=&quot;ipv6.disable=1 splash quiet &quot; 执行命令 1sudo update-grub 重启系统 参考资料： 1、博客园：deepin-wine-qq无法加载图片解决方案 2、深度论坛：终于发现QQ图片转圈的原因了 3、deepin15.11下QQ闪退和图片不加载问题","link":"/2020/04/07/%E5%B0%8F%E6%8A%80%E5%B7%A7/%E8%A7%A3%E5%86%B3deepin-qq-tim%E6%97%A0%E6%B3%95%E6%98%BE%E7%A4%BA%E5%A4%B4%E5%83%8F%E5%92%8C%E5%9B%BE%E7%89%87%E7%9A%84%E9%97%AE%E9%A2%98/"},{"title":"阿里云服务器上手问题","text":"又忍不住开始剁手，在阿里云搞了一个服务器（虽然也不知道干嘛）。记录一下整个过程以及遇到的问题。 1、新用户免费体验有一个新用户的免费体验套餐，开发者的分为两种。第一种性能低一点但是时间长，第二章性能好一点但是时间短。 2、学生优惠阿里云的学生服务器叫“云翼计划”，一个月9.5元。跟腾讯云相比，不限续费次数，很实惠！同时24岁以下自动获得学生身份，CPU性能不限。 套餐也是分为两种，第一种性能好，限流量（1000G/月，应该够了）；第二种差一些，但是无限流量。 3、远程连接首先在windows菜单里面搜索“远程”，然后输入服务器的公网IP地址进行登录。 在阿里云的控制台里面把自己服务器的登陆密码改掉，改掉之后要重启哦！然后接着连接。 4、通过ie浏览器下载文件 登入之后ie浏览器会报错如下： 打开IE浏览器，单击右上侧设置图标，然后单击 Internet选项。 单击 安全 &gt; Internet &gt; 自定义级别，然后单击 下载 &gt; 文件下载 &gt; 启用 &gt; 确定。 参考资料： 1、如何使用远程桌面连接云服务器 (以阿里云为例) 2、Windows实例中无法通过IE浏览器下载文件","link":"/2019/12/05/%E5%B0%8F%E6%8A%80%E5%B7%A7/%E9%98%BF%E9%87%8C%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E6%89%8B%E9%97%AE%E9%A2%98/"},{"title":"GANs简述","text":"GANs概述：内置两个神经网络–生成器G和判断器D。生成器会产生一个假的输出，目的是为了能欺骗判断器；而判断器的目的是为了能准确地判断生成器发来的结果。 适用于：数据较少，但要求较高的地方 缺点： 难训练，不稳定。生成器和判别器之间需要很好的同步，但是在实际训练中很容易D收敛，G发散。D/G 的训练需要精心的设计 模式缺失（Mode Collapse）问题。GANs的学习过程可能出现模式缺失，生成器开始退化，总是生成同样的样本点，无法继续学习 特征： 具有创造性（具有制造以假乱真的能力） 类似于周伯通的左右互搏之术，无聊的时候自己玩，慢慢功力也惊人了 应用案例： |提高图片分辨率 |照片修复(这就是我们需要用到的地方，修补缺陷再和原图量化差距) |生成假的人脸（实际上这些人不存在） |根据人脸生成对应的漫画表情（iPhone的相机有类似的应用） |图像风格迁移（让左上角的原图获得其他图片的风格，形成了新的图片） |3D自动建模– 给出多个不同角度的2D图像，就可以生成一个3D模型 参考资料： 1、生成对抗网络 – Generative Adversarial Networks | GAN 2、Artistic Style Transfer with Convolutional Neural Network 3、Understanding Generative Adversarial Networks (GANs)","link":"/2019/10/30/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/GANs%E7%AE%80%E8%BF%B0/"},{"title":"tensorflow2.0可视化--类激活图","text":"卷积神经网络在分类问题中如何更好地可视化以证明它确实学习到了一些“知识”？这是写论文的时候导师给我的一个难题。 集思广益之后我发现了这个——“类热力图”。它可以表现出卷积神经网络具体在关注哪些地方，对哪些特征比较敏感。 类激活映射(CAM)是一种生成热力图的技术，用于突出图像的类的特定区域。 由于最终的表达形式看起来像是热力图，即神经网络越“重视”的地方越红，所以我把它叫做“类热力图”，但是多数时候我们都叫它“类激活图”。 如果将“类热力图”在训练过程中可视化，我们将会得到以下的效果。 计算方法：给定一张输入图像，对于一个卷积层的输出特征，用类别相对于通道的梯度对这个特征图中的每个通道进行加权。 通俗地来讲，就是计算最后一个卷积层对应预测结果的梯度，梯度越大代表该通道越重要，越重要的通道最后就越红色。 程序实现包括以下几个步骤： 载入库和模型 读取一张图片进行判断 计算类激活图 将类激活图加诸原来的图像上面 我在我先前训练的tensorflow2.0图像分类实例跑了一下，得到了以下结果： 代码下载：我的Github仓库 参考资料： 1、可视化卷及神经网络热力图 2、论文：Grad-CAM: Why did you say that? 3、知乎大佬：如何利用CAM（类激活图）动态可视化模型的学习过程","link":"/2019/11/26/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/tensorflow2.0%E5%8F%AF%E8%A7%86%E5%8C%96--%E7%B1%BB%E7%83%AD%E5%8A%9B%E5%9B%BE/"},{"title":"tensroflow实战--训练BP神经网络","text":"BP(back propagation)神经网络是1986年由Rumelhart和McClelland为首的科学家提出的概念，是一种按照误差逆向传播算法训练的多层前馈神经网络，是目前应用中最基本的神经网络。 运行环境：tensorflow1.14.0 新建程序文件打开ide我这里使用的是jupyter notebook，优点是容易调试，简单清爽。 在终端输入jupyter notebook即可在浏览器里面打开，windows是在cmd里面输入。 载入必要的库123456789# 第一步：引入库import tensorflow as tfimport numpy as npimport matplotlib.pyplot as plt%matplotlib inlinefrom skimage.io import imreadfrom skimage.transform import resizeimport osimport random 载入封装好的函数 封装生成参数函数，全连接层函数等 12345678910111213141516# 第二步：封装卷积函数等def weight_variable(shape): initial = tf.truncated_normal(shape, mean=0, stddev=0.01) #正态初始化 return tf.Variable(initial)def bias_variable(shape): initial = tf.constant(0.1, shape=shape) return tf.Variable(initial)def fulc(x,next_depth): depth = x.get_shape()[-1].value w = weight_variable([depth, next_depth]) b = bias_variable([next_depth]) r = tf.nn.relu(tf.nn.bias_add(tf.matmul(x, w), b)) return r 封装读取图片函数（顺便给标签） 123456789101112131415161718192021222324252627282930# 第三步：封装读取图片并自动给标签函数def load_images(path): contents = os.listdir(path) classes = [each for each in contents if os.path.isdir(os.path.join(path,each))] print('目录下有%s' % classes) # 用labels来存储图片的类别 labels = [] # images数组用来存储图片数据 images = [] # 对每个不同种类读取图片到list并且+标签 for each in classes: class_path = os.path.join(path,each) files = os.listdir(class_path) print(\"Starting {} images\".format(each),'数量为',len(files)) for ii, file in enumerate(files, 1): # 载入图片并放入batch数组中 img = imread(os.path.join(class_path, file)) img = img / 255.0 img = resize(img, (32, 32)) images.append(img.reshape((32,32,3))) labels.append(each) images = np.array(images) #将labels的list形式转换为one_hot_label from sklearn.preprocessing import LabelBinarizer lb = LabelBinarizer() lb.fit(labels) labels_vecs = lb.transform(labels) print('总共读取了%d张图片'%images.shape[0]) # print(labels,labels_vecs) return images,labels_vecs # 返回图片以及对应的标签 随机抽取图片并打乱顺序 123456789101112131415def next_batch(train_data, train_target, batch_size): #抽取数据 index = [ i for i in range(0,len(train_data))] np.random.shuffle(index); batch_data = np.zeros((batch_size,train_data.shape[1],train_data.shape[2],train_data.shape[3])); batch_target = np.zeros((batch_size,train_target.shape[1])); rand = random.randint(1,4)*2 for i in range(0,batch_size): batch_data[i,:,:,:] = train_data[index[i],:,:,:] #rotate(train_data[index[i]],rand,height,width) batch_target[i,:] = train_target[index[i],:] state = np.random.get_state() np.random.shuffle(batch_data) np.random.set_state(state) np.random.shuffle(batch_target) return batch_data, batch_target 封装神经网络结构把上面的封装好的函数拿来用。 12345678910111213141516# 第四步：封装神经网络的创建函数def create(x_images,keep_prob):#x_images的shape是h,w,d h,w,d=x_images.get_shape().value #first fully layer h_conv_flat = tf.reshape(x_images,[-1,h*w*d]) h_fc1 = fulc(h_conv_flat,1024) h_fc1_drop = tf.nn.dropout(h_fc1, keep_prob) #second fully layer h_fc2 = fulc(h_fc1_drop,1024) h_fc2_drop = tf.nn.dropout(h_fc2, keep_prob) #third full layer h_fc3 = fulc(h_fc2_drop,1) out = tf.nn.sigmoid(h_fc3,name='out') # 二分类（输出为1个数字）可以用sigmoid；多分类用softmax print('模型建立好了！') return out tensorflow特色占位在tensorflow1.x版本内，训练前需要先在内存中“占位”。 既然如此，我们把模型创建、损失函数的定义、准确率的定义也放到这一块。 123456789101112131415161718192021# 占位x_images = tf.placeholder(tf.float32,[None,32,32,3],name='x_images')y = tf.placeholder(tf.float32,[None,1],name='y')keep_prob = tf.placeholder(tf.float32,name='keep_prob')# 模型创建y_conv = create(x_images,keep_prob)# 定义损失函数、预测函数和训练过程pred = tf.round(y_conv,name='predict')cross_entropy = tf.reduce_mean(tf.reduce_mean(tf.square(y_conv-y)),name='cross_entropy')train_step = tf.compat.v1.train.AdamOptimizer(1e-4).minimize(cross_entropy)# 多分类定义准确率# correct_prediction = tf.equal(tf.argmax(pred,1),tf.argmax(y,1))# correct_prediction = tf.cast(correct_prediction, tf.float32)# accuracy = tf.reduce_mean(correct_prediction,name='accuracy')# 二分类定义准确率correct_prediction = tf.equal(pred,y)correct_prediction = tf.cast(correct_prediction, tf.float32)accuracy = tf.reduce_mean(correct_prediction,name='accuracy') 开始训练训练目标：训练集{batch_x,batch_y}100%正确 训练集：从{train_x，train_y}中抽取20对 每10次迭代打印并记录一次loss&amp;acc值 1234567891011121314151617181920212223242526272829saver = tf.compat.v1.train.Saver()# 为保存模型做准备with tf.Session() as sess: sess.run(tf.compat.v1.global_variables_initializer()) step = 1 acc=0 while acc!=1:# 正确率达到100%才结束训练 batch_x,batch_y = next_batch(train_x,train_y,20) # print(batch_y) _ = sess.run(train_step,feed_dict={x_images: batch_x, y: batch_y, keep_prob: 0.75}) if step % 10 == 0: predt,acc,loss=sess.run([pred,accuracy,cross_entropy],feed_dict={x_images: batch_x, y: batch_y, keep_prob: 1.}) print ('step:%d,train loss:%f' % (step,loss)) print('train accuracy:%f' % acc) # 把训练损失的变化记录到本地，以便于以后的查阅 with open(\"trainloss.txt\",\"a+\") as f: f.write('step:%d,train loss:%f\\n' % (step,loss)) # ---下面这个部分是为了接下来的误差、准确率的可视化--- if step==10: l = np.array(loss) a = np.array(acc) s = np.array(step) else: l = np.append(l,np.array(loss)) a = np.append(a,np.array(acc)) s = np.append(s,np.array(step)) # ---结束可视化数据的收集--- step += 1 saver.save(sess,\"./model/net.ckpt\")# 当训练完成，把参数保存下来 训练过程的可视化使用以下代码 12345678910plt.plot(s,l)plt.title('step-loss')plt.xlabel('step')plt.ylabel('loss')plt.show()# -------loss&amp;&amp;acc---------plt.plot(s,a)plt.title('step-acc')plt.xlabel('step')plt.ylabel('acc')plt.show() 效果如图： KDUrJH.png 最后：本次实验中训练次数较少，且没有设置测试集或验证集，因此仅能作为参考，具体项目切不可如此。","link":"/2019/10/26/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/tensroflow%E5%AE%9E%E6%88%98--%E8%AE%AD%E7%BB%83BP%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"},{"title":"tensorflow2.0下运行1.x版本的代码","text":"遇到的问题：tensorflow1.x的许多API在2.0版本中弃用了，怎么办？只能动手改代码了吗，可是很多代码都是复制粘贴的，看懂就要好久。 当我在苦苦改代码时，涉及到一个tf.function函数的操作怎么也改不掉报错，于是询问万能的群友，他说有一个方法可以“把程序简单地从1升级到2”。百度了下，虽然没找到“升级”方法，但是找到了将tensorflow“降级”运行的方法！ 在程序文件的开头加入以下两行代码： 1import tensorflow.compat.v1 as tftf.disable_v2_behavior() 程序就欢快地跑起来啦！ 参考资料： 1、升级到tensorflow2.0，我整个人都不好了","link":"/2019/11/19/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/tensorflow2.0%E4%B8%8B%E8%BF%90%E8%A1%8C1.x%E7%89%88%E6%9C%AC%E7%9A%84%E4%BB%A3%E7%A0%81/"},{"title":"tensorflow卷积等操作的高级封装","text":"前一段时间写了一些程序，自己搭建卷积神经网络的时候需要用到不少tensorflow的自带低级封装还有一些常用的读取操作等，虽然已经有了keras等高级封装可以直接调用，但还是想自己写一写。 tensorflow版本：1.1.4 1. 卷积函数1234567891011121314151617def weight_variable(shape): initial = tf.truncated_normal(shape, mean=0, stddev=0.01)#正态初始化 return tf.Variable(initial)def bias_variable(shape): initial = tf.constant(0.1, shape=shape) return tf.Variable(initial)def conv2d(x, W):#步长为1 return tf.nn.conv2d(x, W, strides=[1, 1, 1, 1], padding='SAME')def conv(x,next_depth): depth = x.get_shape()[-1].value w = weight_variable([3, 3, depth, next_depth]) b = bias_variable([next_depth]) r = tf.nn.relu(tf.nn.bias_add(conv2d(x, w), b)) return r 2. 池化函数12def max_pool(x): return tf.nn.max_pool(x, ksize=[1, 2, 2, 1],strides=[1, 2, 2, 1], padding='SAME') 3. 读取图片顺便加标签 文件夹结构（假设目录下面有17个文件夹，每个文件夹里面有若干对应种类的图片）： ./ –./dogs –./cats –./tigers … 读取的图片压缩为32323的尺寸，便于神经网络的快速迭代 1234567891011121314151617181920212223242526272829303132333435363738# 调用skimage的函数from skimage.io import imreadfrom skimage.transform import resizedef load_images(path): contents = os.listdir(path) classes = [each for each in contents if os.path.isdir(os.path.join(path,each))] print('目录下有%s' % classes) # 用labels来存储图片的类别 labels = [] # images数组用来存储图片数据 images = [] # 对每个不同种类读取图片到list并且+标签 for each in classes: class_path = os.path.join(path,each) files = os.listdir(class_path) print(\"Starting {} images\".format(each),'数量为',len(files)) for ii, file in enumerate(files, 1): # 载入图片并放入batch数组中 img = imread(os.path.join(class_path, file)) img = img / 255.0 # print(img.shape) img = resize(img, (32, 32)) # print(img.shape) images.append(img.reshape((32,32,3))) labels.append(each) images = np.array(images) #将labels的list形式转换为one_hot_label from sklearn.preprocessing import LabelBinarizer lb = LabelBinarizer() lb.fit(labels) labels_vecs = lb.transform(labels) print('总共读取了%d张图片'%images.shape[0]) # print(labels,labels_vecs) return images,labels_vecs # 返回图片以及对应的标签 4. 神经网络模型的建立下面的示例结构为：3层卷积+2层全连接 图片的输入x_images的shape是32323 123456789101112131415161718192021222324252627282930313233343536373839404142434445def create(x_images,keep_prob):#x_images的shape是32,32,3 h = 32 w = 32 d = 3 #first layer conv1 = conv(x_images,16) pool1 = max_pool(conv1) h = int(np.ceil(h/2)) w = int(np.ceil(w/2)) d = 16 #second layer conv2 = conv(pool1,32) pool2 = max_pool(conv2) h = int(np.ceil(h/2)) w = int(np.ceil(w/2)) d = d*2 #third layer conv3 = conv(pool2,64) pool3 = max_pool(conv3) h = int(np.ceil(h/2)) w = int(np.ceil(w/2)) d = d*2 #first fully layer w_fc1 = weight_variable([h*w*d,1024]) b_fc1 = bias_variable([1024]) h_conv_flat = tf.reshape(pool3,[-1,h*w*d]) h_fc1 = tf.nn.relu(tf.nn.bias_add(tf.matmul(h_conv_flat, w_fc1), b_fc1)) h_fc1_drop = tf.nn.dropout(h_fc1, keep_prob) #second fully layer w_fc2 = weight_variable([1024,1024]) b_fc2 = bias_variable([1024]) h_fc2 = tf.nn.relu(tf.nn.bias_add(tf.matmul(h_fc1_drop, w_fc2), b_fc2)) h_fc2_drop = tf.nn.dropout(h_fc2, keep_prob) #third full layer w_fc3 = weight_variable([1024,17]) b_fc3 = bias_variable([17]) h_fc3 = tf.add(tf.matmul(h_fc2_drop, w_fc3), b_fc3,name='h_fc3') out = tf.nn.softmax(h_fc3,name='out') print('模型建立好了！') return out","link":"/2019/10/20/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/tensorflow%E5%8D%B7%E7%A7%AF%E7%AD%89%E6%93%8D%E4%BD%9C%E7%9A%84%E9%AB%98%E7%BA%A7%E5%B0%81%E8%A3%85/"},{"title":"使用tensorflow2.0建立图像分类网络","text":"既然google官方已经推出了tensorflow2.0的正式版，tensorflow的一些新特性让他变得更加便于使用，未来必将取代tensorflow1.x系列，为了避免被淘汰。我开始尝试tensorflow2.0，这是第一篇关于tensorflow2.0的文章，内容是使用tensotflow2.0实现一个图像分类卷积网络。 keras作为tensorflow的一个子模块添加到里面，故可以方便地调用，和1.x版本里面使用keras没有太大什么区别，有变化的地方我会在下面写出来。 这一次我们还是循规蹈矩地做一个三分类的网络。 1、预读取训练数据 图片数据的预读取可以参照我之前一篇文章《神经网络训练–数据预读取和存储》，但是这里因为tensorflow2.0里面集成的keras特性，训练时采用的labels不可以是独热编码(one-hot label)，取而代之的是索引值，因此需要对预读取的代码进行修改。 这样一来，操作上确实是简单了一些，但是代价是逻辑上的不直观。我个人觉得得不偿失。 修改的部分代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940# 载入库from skimage.io import imreadfrom skimage.transform import resizeimport osimport numpy as np# 路径下图片读取，给与标签def load_images(path,reshape=224): contents = os.listdir(path) classes=[each for each in contents if os.path.isdir(os.path.join(path,each))] print('目录下有%s' % classes) # 用labels来存储图片的类别 labels = [] # images数组用来存储图片数据 images = [] i = 0 # 对每个不同种类读取图片到list并且+标签 for i,each in enumerate(classes,0): class_path = os.path.join(path,each) files = os.listdir(class_path) print(\"Starting {} images\".format(each),'数量为',len(files)) for file in files: # 载入图片并放入batch数组中 img = imread(os.path.join(class_path, file)) img = img / 255.0 # 这里输入的是图片的缩放尺寸 img = resize(img, (reshape, reshape)) images.append(img.reshape((reshape,reshape,3))) labels.append(i) images = np.array(images) labels = np.array(labels) print('总共读取了%d张图片'%images.shape[0]) return images,labels # 返回图片以及对应的标签path='../三类图片/'train_x,train_y = load_images(path)# 以.npy格式存储在当前目录下np.save(\"train_x.npy\",train_x) np.save(\"train_y.npy\",train_y) 2、训练程序部分 主要是以下几个步骤： 载入库 读取训练数据 构建神经网咯模型 开始训练 训练过程可视化 下面是源代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#!/usr/bin/env python# coding: utf-8# 载入库import tensorflow as tffrom tensorflow.keras.layers import Dense, Flatten, Conv2D, Dropout, MaxPooling2Dfrom tensorflow.keras import Model,Sequentialimport matplotlib.pyplot as pltimport numpy as np# 载入训练数据train_x = np.load(\"train_x.npy\")train_y = np.load(\"train_y.npy\")# 展示一个图片作为样本看看plt.imshow(train_x[0])plt.show()print(train_x.shape)print(train_y.shape)# 模型构建model = Sequential()model.add(Conv2D(32, 3, activation='relu', input_shape=(224, 224, 3)))model.add(MaxPooling2D((2, 2)))model.add(Conv2D(64, 3, activation='relu'))model.add(MaxPooling2D((2, 2)))model.add(Conv2D(64, 3, activation='relu'))model.add(MaxPooling2D((2, 2)))model.add(Conv2D(128, 3, activation='relu'))model.add(MaxPooling2D((2, 2)))model.add(Conv2D(128, 3, activation='relu'))model.add(MaxPooling2D((2, 2)))model.add(Flatten())model.add(Dropout(0.2))model.add(Dense(1024,activation='relu'))model.add(Dense(1024,activation='relu'))model.add(Dense(3,activation='softmax'))# 模型编译model.compile(optimizer='adam', loss='sparse_categorical_crossentropy', metrics=['accuracy'])# 开始训练history = model.fit(train_x, train_y, batch_size=20, epochs=5)# 可视化l = np.array(history.history['loss'])a = np.array(history.history['accuracy'])step = np.linspace(1,50,50)plt.plot(step,l,label=\"Train Loss\")plt.legend(loc='upper right')plt.title('epoch-loss')plt.xlim((0, 50))plt.gca().set_ylim(bottom=0)plt.xlabel('epoch')plt.ylabel('loss')plt.show()plt.plot(step,a,label=\"Train Acc\")plt.legend(loc='lower right')plt.title('epoch-acc')plt.xlim((0, 50))plt.gca().set_ylim(bottom=0)plt.xlabel('epoch')plt.ylabel('acc')plt.show() Reference: 1、Convolutional Neural Network (CNN) 2、我的Github仓库源码","link":"/2019/11/18/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E4%BD%BF%E7%94%A8tensorflow2.0%E5%BB%BA%E7%AB%8B%E5%9B%BE%E5%83%8F%E5%88%86%E7%B1%BB%E7%BD%91%E7%BB%9C/"},{"title":"keras训练卷积神经网络","text":"Keras 是一个用 Python 编写的高级神经网络 API，它能够以 TensorFlow, CNTK, 或者 Theano 作为后端运行。Keras 的开发重点是支持快速的实验。能够以最小的时延把你的想法转换为实验结果，是做好研究的关键。 如果你在以下情况下需要深度学习库，请使用 Keras： 允许简单而快速的原型设计（由于用户友好，高度模块化，可扩展性）。 同时支持卷积神经网络和循环神经网络，以及两者的组合。 在 CPU 和 GPU 上无缝运行。 Keras的后台支持tensorflow和theno，看起来就像是一个非常正式的高级封装，非常有助于快速的开发。最近我也正从tensorflow的低级封装转到高级封装，没有别的原因，生命苦短。 本文将进行一个猫狗分类。 首先载入库当然如果没有安装keras的要先安装一下哦，安装keras之前要保证自己的设备上已经有了tensorflow或者theno。 12345import numpy as npimport kerasfrom keras.models import Sequentialfrom keras.layers import Dense, Dropout, Flattenfrom keras.layers import Conv2D, MaxPooling2Dfrom keras.optimizers import SGD 接着构建模型这里构建模型超级简单，使用Sequential()新建之后再add就可以了。 1234567891011121314151617model = Sequential()# 输入: 3 通道 32x32 像素图像 -&gt; (32, 32, 3) 张量。# 使用 32 个大小为 3x3 的卷积滤波器。model.add(Conv2D(32, (3, 3), activation='relu', input_shape=(32, 32, 3)))model.add(Conv2D(32, (3, 3),activation='relu'))model.add(MaxPooling2D(pool_size=(2, 2)))model.add(Dropout(0.25))model.add(Conv2D(64, (3, 3), activation='relu'))model.add(Conv2D(64, (3, 3), activation='relu'))model.add(MaxPooling2D(pool_size=(2, 2)))model.add(Dropout(0.25))model.add(Flatten())model.add(Dense(256, activation='relu'))model.add(Dropout(0.5))model.add(Dense(2, activation='softmax')) 接下来读取训练数据数据的预读取已经完成，详见神经网络训练–数据预读取和存储。 训练数据一共是20对图片和标签，其中标签最好使用keras的to_categorical转化一下。我这里train_y原来就是0/1，shape是(20,1)，经过转化之后，值变成了[1,0]/[0,1]，shape变成了(20,2)。 12345# 直接读取之前存储的二进制文件train_x = np.load(\"train_x.npy\")train_y = np.load(\"train_y.npy\")# 必须要把label搞一个to_categoricaltrain_y = keras.utils.to_categorical(train_y) 编译、训练选用梯度下降法SGD，编译之后训练100个epoch。 12345sgd = SGD(lr=0.01, decay=1e-6, momentum=0.9, nesterov=True)model.compile(loss='categorical_crossentropy', optimizer=sgd, metrics=[\"accuracy\"])his = model.fit(train_x, train_y, batch_size=10, epochs=100)score = model.evaluate(train_x, train_y, batch_size=20) 过程可视化将mode.fit的结果通过图像展示出来看看。 1234567891011121314151617181920l = np.array(his.history['loss'])import matplotlib.pyplot as pltstep = np.linspace(1,100,100)plt.plot(step,l,label=\"Train Loss\")plt.legend(loc='upper right')plt.title('epoch-loss')plt.xlim((0, 100))plt.gca().set_ylim(bottom=0)plt.xlabel('epoch')plt.ylabel('loss')plt.show()a = np.array(his.history['accuracy'])plt.plot(step,a,label=\"Train Accuracy\")plt.legend(loc='lower right')plt.title('epoch-acc')plt.xlim((0, 100))plt.ylim((0, 1.005))plt.xlabel('epoch')plt.ylabel('acc')plt.show() [ 参考资料： 1、Keras中文文档–开始使用 Keras Sequential 顺序模型","link":"/2019/11/06/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/keras%E8%AE%AD%E7%BB%83%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"},{"title":"目标检测(Object Detection)简易应用","text":"目标检测是计算机视觉中最重要最核心的部分之一，在这里面综合运用了计算机视觉上的各种方法和手段，对于无人驾驶等行业具有重要的意义。本篇文章主要使用Tensorflow Hub对于目标检测算法进行简单的应用。 1、Tensorflow HubTensorFlow Hub 是一个库，用于发布、发现和使用机器学习模型中可重复利用的部分。模块是一个独立的 TensorFlow 图部分，其中包含权重和资源，可以在一个进程中供不同任务重复使用（称为迁移学习）。 使用较小的数据集训练模型， 改善泛化效果，以及 加快训练速度 2、应用环境：tensorflow2.0 源代码下载：TF-Hub Object Detection Example 有几个问题： 只能整个仓库一起下载，但是整个仓库不大，只有500+k 国内基本上用不了TF Hub，被墙了，如果要下载TF Hub上对应的model，必须要挂个梯子 缩进问题很严重 3、目标检测的发展历程 论文可以参见参考资料1下载，代码可以参见参考资料2下载。 参考资料： 1、Gtihub:deep_learning_object_detection 2、Github:awesome-object-detection 3、TF-Hub","link":"/2019/11/20/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B(Object%20Detection)%E7%AE%80%E6%98%93%E5%BA%94%E7%94%A8/"},{"title":"如何在电脑上安装tensorflow","text":"Tensorflow是谷歌的一个深度学习方面的开源框架，其源代码见诸于github。1.x版本入门的时候有点难度，需要配置很多参数才可以；2.x版本貌似有了很大改观，在2.x中，官方非常提倡使用keras。无论是1还是2版本，总体来说还是大大方便了我们实现各种神经网络的。 不管怎么说，让我们首先安装tensorflow吧（现在已经默认2.0版本）。 1. Windows系统 首先需要安装python（最新的版本是python3.8） ‘win+R’ 组合键打开命令提示符，输入‘cmd’ 进入小黑框 输入 ‘pip install tensorflow’ ，等待安装结束即可 如果需要安装gpu版本的，查询自己的电脑GPU计算能力等是否符合tensorflow的GPU版本要求，确认无误后输入命令 ‘pip install tensorflow-gpu’。结束后需要配置CUDA等，这部分可以参考百度PaddlePaddle的安装说明。 2. Deepin系统 Deepin系统很好，自带python2和python3，直接在终端输入 ‘pip3 install tensorflow’ 即可 Deepin对显卡的驱动好像不怎么样，所以如果有同学知道怎么在deepin上面配置tensorflow的GPU版本麻烦告诉我，谢谢。","link":"/2019/10/20/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E5%A6%82%E4%BD%95%E5%9C%A8%E7%94%B5%E8%84%91%E4%B8%8A%E5%AE%89%E8%A3%85tensorflow/"},{"title":"目标检测--YOLO的原理步骤学习笔记","text":"YOLO (You Only Look Once)是一种端到端学习的目标检测算法，已经更新迭代了好几代，因为响应迅速、抓取准确等优点被广泛使用。本文以吴恩达深度学习作业(提取码:cw7y)中的无人驾驶路测场景为例子整理。 第一步：网格化/训练网络将训练图片（这里的shape是608，608，3）划分为19x19的网格，每一个网格有两个属性——锚框（anchor box）和类别（classes）。每个网格对应有5个锚框，80个类别。 ![architecture](https://s2.ax1x.com/2019/11/01/K7v22q.png 因此，我们将要训练一个端到端的神经网络，输入的shape是（m,608,608,3），输出的shape是（m,19,19,5,85）。这里的m是一次输入的图片数量。我们观察上图可以看到85=80类别+5参数，这5个参数分别代表什么呢？ 符号 意义 pc 目标网格内有无要检测的目标，取值为[0,1] bx|by bx 和by确定的是边界框相对于网格单元的中心坐标 bw|bh bw 和bh确定的是边界框相对于整个图像的宽和高 加上这5个参数，我们就能得到边界框的准确位置了。通过下图，我们可以观察这5个参数究竟是如何运作的，能得到什么。 例设这里的box1是我们取神经网络的output[0,0,0,0,:]，神经网络判断这个格子里面有要检测的目标，可能性为pc，我们把pc乘上ci就得到了全局的存在可能性{pcci}，score=max{pcci}=0.44，查一下数组的索引得到对应的类别是car。 本来$$\\sum_{i=0}^nc_i=1$$ $c_i$对应的是以这个格子为系统，各个分类的概率，当我们乘上pc之后， pcci就变成了一个全局的概率，有利于以后不同格子之间的对比。 当我们把这个神经网络训练好了之后，如果不考虑锚框的话，就可以得到下图类似的可视化效果 考虑锚框的话，就得到下图可视化效果 第二步：过滤锚框 阈值过滤（thresholding） 经过第一步的分析，每一个锚框都有一个对应的score属性，这个属性在全局是公平的。这一步，我们选定一个阈值排除掉score过于小的锚框，一般可以取0.7，视情况调整。 非最大值抑制（Non-max suppression） 有的时候，对于同一辆车，神经网络会给出多个锚框，在这种情况下我们使用非最大值抑制就可以选择出最合适的一个框。 非最大值抑制使用了一个重要指标——交并比(IoU, Intersection over Union)，其定义图如下。 在本例中，给三个锚框按照score降序分别标号为A,B,C， 如果B和C与A的交并比大于一个阈值sigma，就舍弃B,C并保留A；如果B和C与A的交并比均小于阈值sigma，则保留B和C，再对B和C进行非最大值抑制。 第三步：边框回归（Bounding Box Regression）为什么要进行边框回归呢？因为有的时候神经网络返回的锚框并不准确，如下图红框。因此我们就需要边框回归使得红框拓展为绿框使得边界框变得更加准确。 边框回归的步骤：（详细见参考资料4，我也不太明白） 先做平移变换 再做尺度缩放 总结一图以概之： 参考资料： 1、简书:YOLO 2、Markdown公式、特殊字符、上下标、求和/积分、分式/根式、字体 3、非最大值抑制（Non-max suppression） 4、边框回归(Bounding Box Regression)详解","link":"/2019/11/01/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B--YOLO%E7%9A%84%E5%8E%9F%E7%90%86%E6%AD%A5%E9%AA%A4%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"title":"目标检测--滑动窗口算法的原理和实现","text":"滑动窗口算法作为最原始最简单的深度学习目标检测算法，容易上手并且原理简单，深受鄙人的喜爱。 本文将简单介绍滑动窗口算法的原理并且使用python实现它。 原理 首先选定一个特定大小的窗口，并使用以上的卷积神经网络判断这个窗口中有没有目标物体，滑动目标检测算法会从左上角向右并向下滑动输入窗口，并将截取的图像都输入到 已经训练好的卷积神经网络中 以固定步幅滑动窗口，遍历图像的每个区域 然后使用比以上使用的窗口大一些的窗口，重复进行以上操作。然后再使用比上一次更大的窗口进行图像的截取与检测。 所以无论目标在图像中的什么位置,总有一个窗口可以检测到它。 缺点： 但是滑动窗口目标检测算法有十分消耗计算成本的缺点，因为使用窗口会在原始图片中截取很多小方块,并且卷积神经网络需要一个个的进行处理。虽然使用较大的步长可以有效的节省计算成本，但是粗粒度的检测会影响性能，小步幅和小窗口就会大量的耗费计算成本 早些时候在普通的线性分类器上使用滑动窗口目标检测算法可以有很好的性能，但是对于卷积神经网络这种对于图像识别相当耗费性能的算法而言，需要对滑动窗口算法进行重新设计。 实现1. 载入需要的库123456import numpy as npimport tensorflow as tfimport cv2import timeimport matplotlib.pyplot as pltfrom skimage.io import imreadfrom skimage.transform import resize 2. 神经网络的重载 首先需要提前训练神经网络，这里没有啥好讲的，可以参照我之前的两篇博文 《tensorflow卷积等操作的高级封装》 《tensroflow实战–训练BP神经网络》 重载 调用第一步里面训练好的神经网络，对每一个格子进行0/1判别（0为没有目标，1为有目标） 1234567891011121314time_start = time.time()saver=tf.train.import_meta_graph('./model/model.ckpt.meta') sess=tf.Session()sess.run(tf.compat.v1.global_variables_initializer())saver.restore(sess, tf.train.latest_checkpoint('./model/'))# 直接获取保存的变量# 获取placeholder变量input_x = sess.graph.get_tensor_by_name('x:0')input_y = sess.graph.get_tensor_by_name('y:0')keep_prob = sess.graph.get_tensor_by_name('keep_prob:0')# 获取需要进行计算的operatory_conv = sess.graph.get_tensor_by_name('y_conv:0')time_end = time.time()print('模型重载完成！耗时%ss'%str(time_end-time_start)) 3. 滑动窗口的实现据吴恩达口述，可以使用卷积的操作代替图片的切割， 卷积神经网络的滑动窗口实现提高了整个算法的效率。但是鄙人没能搞明白为什么以及怎么做，因此笔者还是采用了原始的图像切割方法。 先读取图片 1234567def load_image(path): img = imread(path) img = resize(img,(900,900)) return imgpath = '路径'x_image = load_image(path,k) 将大图片分割成30x30的小图片，这里面大图片宽高最好是30的倍数，可以载入的时候先resize一下。上图像切割代码： 123456789101112131415def fenge(image): #得到图片的高和宽 h,w,d = image.shape small_img = np.zeros((int(h/30)*int(w/30),30,30,3)) #30x30图片分割 for i in range(int(h/30)):#行 for j in range(int(w/30)):#列 small_img[i*int(w/30)+j,:,:,:]=image[30*i:30*i+30,30*j:30*j+30,:] small_img = small_img.astype(int) return small_img# 获取image的shapeh,w,d = x_image.shape# 30x30图片分割small_img = fenge(x_image) 原图的shape假设为(900,900,3)，切割之后就变成了(900,30,30,3) 4. 小格子判别图像切割完毕，现在需要对30x30的小格子进行识别。 做出预测： 12345pred = sess.run(y_conv, {input_x: small_img,keep_prob:1.})print(pred.shape)print('预测完成!')img_label = np.zeros(1080,dtype=np.int)img_label = pred[:,0].astype(int) 为存在目标的格子添加边框： 12345678def add_bound(img): img = cv2.rectangle(img,(0,0),(29,29),(255,0,0),1) return img##加边框for i in range(len(img_label)): if img_label[i]==1: small_img[i*30:i*30+30,:,:] = add_bound(small_img[i*30:i*30+30,:,:]) 5. 重排图像并保存123456789101112131415#small_img重排for i in range(int(h/30)):#行 for j in range(int(w/30)):#列 x_image[30*i:30*i+30,30*j:30*j+30,:]=small_img[i*int(w/30)+j,:,:,:]plt.rcParams['savefig.dpi'] = 300 #图片像素plt.rcParams['figure.dpi'] = 100 #分辨率plt.axis('off')plt.imshow(x_image)plt.savefig('judge.png',bbox_inches='tight',pad_inches=0.0)#,dpi=300plt.show()print('图片存好了!')# 关闭tf.sessionsess.close() 6. 效果图 参考资料： 1、[DeeplearningAI笔记]卷积神经网络3.1-3.5目标定位/特征点检测/目标检测/滑动窗口的卷积神经网络实现/YOLO算法","link":"/2019/11/01/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B--%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%AE%97%E6%B3%95%E7%9A%84%E5%8E%9F%E7%90%86%E5%92%8C%E5%AE%9E%E7%8E%B0/"},{"title":"神经网络训练--数据预读取和存储","text":"在我训练卷积神经网络的过程中，每一次训练都需要读取训练图片、测试图片，每一张图片都很大，所以读取数据就需要很长时间。但是训练的时候往往会把图片压缩，因此就产生了将图片第一次读取之后就以训练的shape存储在本地供下一次读取。 我们这里使用numpy将读取进来的图片数据和对用的label存储到同级目录下面。其中，load_images函数使用的是skimage和sklearn两个包，源码可见于tensorflow卷积等操作的高级封装 1234567import numpy as np#首先读取数据path = './pics'train_x,train_y = load_images(path)# 转存为二进制文件方便下次读取np.save(\"train_x.npy\",train_x) np.save(\"train_y.npy\",train_y) 完成之后，下次训练时需要载入，则使用以下代码即可： 123# 直接读取之前存储的二进制文件train_x = np.load(\"train_x.npy\")train_y = np.load(\"train_y.npy\") 这样就迅速得到了训练集内容。 以下是读取展示： 展示其shape 展示其图像","link":"/2019/11/04/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E8%AE%AD%E7%BB%83--%E6%95%B0%E6%8D%AE%E9%A2%84%E8%AF%BB%E5%8F%96%E5%92%8C%E5%AD%98%E5%82%A8/"},{"title":"目标检测训练集标注工具labelImg的配置和使用","text":"我想要自己训练一个目标检测网络，首先需要的就是训练集。可是图片中物体的定位怎么写呢，难道要自己记录目标图像的中心点和锚框大小吗？哭了。。所幸，发现了这个labelImg工具。 作者演示教程： labelImg是一个开源的工具，有可视化界面，如下所示。 安装 Installationwindows下有现成的应用程序可用，百度网盘链接： https://pan.baidu.com/s/1d27UMi 但是在使用这个应用的时候我发现，如果把压缩包解压之后运行这个程序，则小黑框一闪而没，根本用不了。只有在压缩包里面直接打开是可以用的。 使用 Usage 在labelImg文件中，有个data文件夹，里面有predefined_classes.txt记录着分类名称，可以手动更改类别 选择File-&gt;Change Saved Dir（不同版本稍微有些差异，也可能叫做changedefault annatation saved dir）,然后选择一个空文件夹作为你生成的标记xml存放的位置 点击Open Dir选择你的影像图片文件夹 之后，图片便加载进来了，点击左侧Create RectBox，就可以在图像上绘制矩形框了。因为版本差异，绘制矩形框有的需要一直按住鼠标左键，有的则只用初始和结束位置点击一下，视具体版本情况而定。 绘制结束后，会弹出一个框，选择你要标记的类别，比如dog，如果列表里面没有这个类别，可以在方框中输入，最后点击OK。此时，按住Ctrl+S才算保存，之后，可以使用鼠标点击next image进入下一张或者使用快捷键D进入下一张，最终每张图片标注的结果将保存在xml文件中，xml文件和图片名称一致。 快捷键： Ctrl + u Load all of the images from a directory Ctrl + r Change the default annotation target dir Ctrl + s Save Ctrl + d Copy the current label and rect box Space Flag the current image as verified w Create a rect box d Next image a Previous image del Delete the selected rect box Ctrl++ Zoom in Ctrl– Zoom out ↑→↓← Keyboard arrows to move selected rect box 参考资料： 1、源码地址 2、Bilibili视频 3、Windows下深度学习标注工具LabelImg安装和使用指南","link":"/2019/11/23/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E8%AE%AD%E7%BB%83%E9%9B%86%E6%A0%87%E6%B3%A8%E5%B7%A5%E5%85%B7labelImg%E7%9A%84%E9%85%8D%E7%BD%AE%E5%92%8C%E4%BD%BF%E7%94%A8/"},{"title":"jupyter的远程控制","text":"手头有一台亚马逊的ec2微实例闲置，于是就想在这个小小的服务器上搭建一个Jupyter，让我能在任何地方进行远程访问。亲测可行！ 已知： jupyter notebook是基于网页打开的 默认的端口是8888 想法：用内网穿透将8888端口映射出去 结果：失败，jupyter会拒绝我们的访问 解决方案： 生成配置文件 1jupyter notebook --generate-config 生成密码 打开python，创建一个密码。这个密码就是以后我们访问的时候需要输入验证的。 12345&gt;&gt;&gt; from notebook.auth import passwd&gt;&gt;&gt; passwd()Enter password: Verify password: 'sha1:ce...密码串' 把这里的输入密码之后生成的字符串给记下来 修改配置文件 linux下可以使用vim直接修改，命令是 $vim ~/.jupyter/jupyter_notebook_config.py ；windows下，在目录C:\\Users\\Administer\\.jupyter下找到config.py文件，用记事本打开。 把原来的内容清空后，输入以下内容： 12345c.NotebookApp.ip='127.0.0.1'c.NotebookApp.password = u'sha1:ce...刚才复制的那个密码串'c.NotebookApp.open_browser = Falsec.NotebookApp.allow_remote_access = Truec.NotebookApp.port =8888 #指定端口 终端输入jupyter notebook，启动jupyter notebook 开启8888端口映射，即可远程访问！ 我暂时使用的是sunny-ngrok内网穿透，可以用一个免费的隧道进行端口映射。当然你也可以选择花生壳，nat123等工具。 参考资料： 1、简书：玩转jupyter + 远程访问 2、jupyter notebook 初步使用配置调整","link":"/2019/11/29/%E9%AA%9A%E6%93%8D%E4%BD%9C/jupyter%E7%9A%84%E8%BF%9C%E7%A8%8B%E6%8E%A7%E5%88%B6/"},{"title":"python3下安装pip的简单方法","text":"使用一个.py脚本自动安装，非常简单！ 核心步骤： 1wget https://bootstrap.pypa.io/get-pip.py 一、准备工作安装好Python3和wget，如果没有安装好，就输入下面的指令安装。 1sudo apt-get install python3 wget 二、下载安装pip的脚本Bootstrap是美国Twitter公司的设计师Mark Otto和Jacob Thornton合作基于HTML、CSS、JavaScript 开发的简洁、直观、强悍的前端开发框架。不知道为啥可以从它的网站上下载这个脚本。 1wget https://bootstrap.pypa.io/get-pip.py 三、安装以及错误解决！python运行它！ 1sudo python3 get-pip.py 安装结束，可以正常运行pip了。 安装报错： 我安装时报错 原因是没有安装python-distuils这个组件，安装一下就好了 1sudo apt-get install python3-distutils 效果展示 但是，有时候…你是Ubuntu或者Debian，可直接用包管理器安装 pip 1sudo apt-get install python-pip","link":"/2019/10/24/%E9%AA%9A%E6%93%8D%E4%BD%9C/python3%E4%B8%8B%E5%AE%89%E8%A3%85pip%E7%9A%84%E7%AE%80%E5%8D%95%E6%96%B9%E6%B3%95/"},{"title":"nginx挂载静态网页","text":"nginx用的很广，之前在想要内网穿透的时候似乎见过这个名字，但是由于知识储备问题并没有去纠缠。这次我打算用它来挂静态网页。 1、安装nginx首先，直接用apt安装nginx即可，不需要太麻烦。 1sudo apt-get install nginx 安装好了之后，命令行输入sudo nginx。如果安装成功，在浏览器内访问服务器的ip即可得到以下画面。 2、配置网页地址 我这里使用的是hexo生成的静态网页文件，把public目录下的文件复制到Linux下的/home/share/hidden/blog文件夹里面。 接下来修改nginx的配置文件。 1sudo vim /etc/nginx/sites-available/default ​ 找到下面这一段 1234567location / { # First attempt to serve request as file, then # as directory, then fall back to displaying a 404. try_files $uri $uri/ =404; # Uncomment to enable naxsi on this location # include /etc/nginx/naxsi.rules } 加入两行进行修改 123456789location / { # First attempt to serve request as file, then # as directory, then fall back to displaying a 404. try_files $uri $uri/ =404; index index.html; root /home/share/hidden/blog; # Uncomment to enable naxsi on this location # include /etc/nginx/naxsi.rules } 保存之后退出 重新加载nginx配置文件 1sudo nginx -s reload 重启nginx服务 1sudo service nginx restart 3、访问nginx服务打开浏览器输入http://your_linux_ip，应该就可以看见你的网页了。 参考资料： 1、nginx部署前端页面： https://www.jianshu.com/p/e84238f11517 2、基于nginx的静态网页部署：https://blog.csdn.net/ljp1919/article/details/72833982","link":"/2020/04/09/%E9%AA%9A%E6%93%8D%E4%BD%9C/nginx%E6%8C%82%E8%BD%BD%E9%9D%99%E6%80%81%E7%BD%91%E9%A1%B5/"},{"title":"使用Python优雅地将PDF转化为图片","text":"疫情期间，内燃机老师要我们每周在QQ小程序上面用图片的形式提交两次作业，然而我的WPS会员过期了，pdf转图片会有水印，网上逛了一圈，python可以解决这个问题。 一、准备工作安装python库PyMuPDF 1！pip3 install PyMuPDF 二、程序主体 库的导入、函数封装 1234567891011121314151617181920212223242526import sys, fitzimport osimport datetime def pyMuPDF_fitz(pdfPath, imagePath): startTime_pdf2img = datetime.datetime.now()#开始时间 print(\"imagePath=\"+imagePath) pdfDoc = fitz.open(pdfPath) for pg in range(pdfDoc.pageCount): page = pdfDoc[pg] rotate = int(0) # 每个尺寸的缩放系数为1.3，这将为我们生成分辨率提高2.6的图像。 # 此处若是不做设置，默认图片大小为：792X612, dpi=96 zoom_x = 1.33333333*2 #(1.33333333--&gt;1056x816) (2--&gt;1584x1224) zoom_y = 1.33333333*2 mat = fitz.Matrix(zoom_x, zoom_y).preRotate(rotate) pix = page.getPixmap(matrix=mat, alpha=False) if not os.path.exists(imagePath):#判断存放图片的文件夹是否存在 os.makedirs(imagePath) # 若图片文件夹不存在就创建 pix.writePNG(imagePath+'/'+'images_%s.png' % pg)#将图片写入指定的文件夹内 endTime_pdf2img = datetime.datetime.now()#结束时间 print('pdf2img时间=',(endTime_pdf2img - startTime_pdf2img).seconds,'s') 主函数 12345if __name__ == \"__main__\": homeworkname='内燃机构造与原理平时作业七' pdfPath = '../'+homeworkname+'.pdf' imagePath = '../'+homeworkname+'/' pyMuPDF_fitz(pdfPath, imagePath) 参考资料： 1、Python将PDF转成图片——PyMuPDF和pdf2image：https://blog.csdn.net/zbj18314469395/article/details/98329442","link":"/2020/03/15/%E9%AA%9A%E6%93%8D%E4%BD%9C/%E4%BD%BF%E7%94%A8Python%E4%BC%98%E9%9B%85%E5%9C%B0%E5%B0%86PDF%E8%BD%AC%E5%8C%96%E4%B8%BA%E5%9B%BE%E7%89%87/"},{"title":"windows上安装自带的linux","text":"因为专业课程原因，需要使用Solidworks，我不得不把电脑从deepin回退到Windows10。怀着对linux简单粗暴的命令行的回忆，我发现了Windows上可以下载自带的Ubuntu等linux系统，开心坏了。以下就是具体的安装步骤。 修改设置 首先我们要打开Windows功能 在这里把勾打上 然后打开设置–更新和安全–针对开发人员，选择开发人员模式–确定启动，就行了 安装Ubuntu 打开MS Store，搜索linux 选择Ubuntu并安装 打开Ubuntu程序，配置用户名和密码，Over~ 参考资料： 1、在win10下安装自带的linux,并进行相应的配置","link":"/2019/11/01/%E9%AA%9A%E6%93%8D%E4%BD%9C/windows%E4%B8%8A%E5%AE%89%E8%A3%85%E8%87%AA%E5%B8%A6%E7%9A%84linux/"},{"title":"一行python搭建webdav","text":"想要建一个webdav，然后研究了apache，nginx均失败，最后还是python最简单地完成了我们的要求。 一、Wsgidav 官网：https://wsgidav.readthedocs.io/en/latest/index.html 安装 1pip install cheroot wsgidav cheroot lxml pam 使用 123wsgidav --host=0.0.0.0 --port=80 --root=/tmp --auth=anonymous # 匿名wsgidav --host=0.0.0.0 --port=80 --root=/tmp --auth=pam-login # Linux下账号wsgidav --host=0.0.0.0 --port=80 --root=/tmp --auth=nt # Windows下账号 二、大问题Ubuntu下实测，pam模块是有问题的。经过观察代码，这是python2时代的产物，而wsgidav采用pam来验证会带来一些坑。 坑1：字符报错，无效字符 python3的print有括号的，到该路径的文件中加上去即可 坑2：AttributeError: module ‘pam’ has no attribute ‘pam’ 找到文件，随便改一下，能用就行。 坑3：Linux下密码登录失效，一直在报pam.authenticate错误。 重写，反正就我一个人用。把用户名密码写死！pam_dc.py文件全文如下。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576# -*- coding: utf-8 -*-# (c) 2009-2020 Martin Wendt and contributors; see WsgiDAV https://github.com/mar10/wsgidav# Licensed under the MIT license: http://www.opensource.org/licenses/mit-license.php\"\"\"Implementation of a domain controller that allows users to authenticate againsta Pluggable Authentication Module ('PAM').Used by HTTPAuthenticator. Only available on linux and macOS.See https://wsgidav.readthedocs.io/en/latest/user_guide_configure.html\"\"\"from __future__ import print_functionfrom wsgidav import utilfrom wsgidav.dc.base_dc import BaseDomainControllerimport pam__docformat__ = \"reStructuredText\"_logger = util.get_module_logger(__name__)class PAMDomainController(BaseDomainController): def __init__(self, wsgidav_app, config): super(PAMDomainController, self).__init__(wsgidav_app, config) self.pam = pam.PamHandle()# origin is pam.pam, replace it # auth_conf = config[\"http_authenticator\"] dc_conf = config.get(\"pam_dc\", {}) self.pam_service = dc_conf.get(\"service\", \"login\") self.pam_encoding = dc_conf.get(\"encoding\", \"utf-8\") self.pam_resetcreds = dc_conf.get(\"resetcreds\", True) def __str__(self): return \"{}('{}')\".format(self.__class__.__name__, self.pam_service) def get_domain_realm(self, path_info, environ): return \"PAM({})\".format(self.pam_service) def require_authentication(self, realm, environ): return True def verify(self, user_name,password):# write die, 写死 if user_name=='lankning' and password=='123456': return True else: return False def basic_auth_user(self, realm, user_name, password, environ): pam = self.pam is_ok = self.verify(user_name,password) # pam.authenticate( # user_name, # password, # service=self.pam_service, # resetcreds=self.pam_resetcreds, # encoding=self.pam_encoding, # ) if is_ok: _logger.debug(\"User '{}' logged on.\".format(user_name)) return True _logger.warning( \"pam.authenticate('{}', '***', '{}') failed with code {}: {}\".format( user_name, self.pam_service, pam.code, pam.reason ) ) return False def supports_http_digest_auth(self): # We don't have access to a plaintext password (or stored hash) return False 这就可以用了。。。","link":"/2020/07/31/%E9%AA%9A%E6%93%8D%E4%BD%9C/%E4%B8%80%E8%A1%8Cpython%E6%90%AD%E5%BB%BAwebdav/"},{"title":"安卓手机安装Linux","text":"只要是安卓4版本及以上的废旧手机，无论如何都比市场上面卖的一两百块钱的开发板好，尤其体现在性能和集成度上。无论是为了发扬极客精神还是为了学习Linux亦或者进行一些小项目的开发，使用淘汰下来的安卓手机都是一件经济实效的事情。 准备工作： 电脑 x 1 安卓手机 x 1 数据线 x 1 一、手机获得root权限1. 先尝试使用360一键root获取root权限我手边的手机是VIVO Y29L，我先使用刷机APP进行刷机。多次刷机之后仍然显示失败。 2. 使用“奇兔刷机”进行刷机奇兔刷机下载： http://www.7to.cn/ 在ROM市场可以找到一些符合条件的ROM包，下载到本地之后选用本地ROM进行刷机。安装指示进行操作，示意图如下。我这里刷的是MIUI8，因为MIUI可以直接给系统设置中给应用root权限。 二、安装Linux2.1 安装Linux deploy由于高版本的linuxdeploy.apk安装包无法在安卓4系统下解析，因此需要根据手机的出厂时间，选择附近时间的Linux Deploy发行版apk文件。 Linux Deploy的Github地址： https://github.com/meefik/linuxdeploy/releases 2.2 授予Linux deploy以root权限在运行Linux deploy时，点击安装，系统自带的root管理器会弹出是否允许使用root权限的对话框，选择“是”。 2.3 选择要安装的选项尤其关注要安装的linux发行版、是否安装ssh和VNC。 三、完成并享受下载VNC Viewer：https://www.realvnc.com/en/connect/download/viewer/ 通过VNC连接手机上的Linux系统，效果如下👇","link":"/2020/02/19/%E9%AA%9A%E6%93%8D%E4%BD%9C/%E5%AE%89%E5%8D%93%E6%89%8B%E6%9C%BA%E5%AE%89%E8%A3%85Linux/"},{"title":"使用samba搭建内网文件服务器","text":"近期被百度网盘的限速困扰，再加上淘宝上各种家用nas的广告轰炸，于是就起了一个自建nas的想法。作为尝试的第一步，应该是掌握在linux上搭建文件服务器的方法，于是就有了这篇小短文。 环境： 安卓手机（已root）上面运行linux deploy 电脑系统deepin，通过ssh连接手机 第一步：安装Samba输入命令： 1sudo apt-get install samba 没有意外的话安装就完成了。 第二步：新建（或制定）共享文件夹 新建共享文件夹 在这里我在home目录下新建一个share文件夹 1sudo mkdir /home/share 给予共享文件夹权限 1sudo chmod 777 /home/share 第三步：创建登录账号 添加一个账户名，比如新账户名叫做pony 1sudo useradd pony 为新建的账户添加密码，输入此命令后会确认两遍密码 1sudo smbpasswd -a pony 第四步：修改配置文件 使用vim打开配置文件，一般配置文件的目录都是固定的 1sudo vim /etc/samba/smb.conf 在开头的 [gobal] 区域添加 1security = user 在最后添加一段 注解： comment是欢迎语，随便你写什么； path路径要填入自己第二步新建文件夹的地址； 剩下的是配置能否写入等权限，不用改动 1[share]comment = Welcome to SMB server!path = /home/sharebrowseable = yeswritable = yesguest ok = yes 第五步：启动smb输入以下命令即可启动smb 1sudo service smbd restart 现在，在你的文件管理器里面键入”smb://ip地址/share”就能看到你的文件服务器里的内容啦。附图如下： 2019年11月份 Windows下实测写入速度，还是比较给力的：","link":"/2019/10/21/%E9%AA%9A%E6%93%8D%E4%BD%9C/%E4%BD%BF%E7%94%A8samba%E6%90%AD%E5%BB%BA%E5%86%85%E7%BD%91%E6%96%87%E4%BB%B6%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"title":"记一次电子书的制作（从爬取网上资源开始）","text":"想到好久没有看小说了，去各大网站看看之后发现了一些爽文，可是他们都没有提供一键下载的服务。由此就产生了这一篇记录，涉及python爬虫知识、文件格式转化问题，参考了各大论坛的操作，最后以epub的格式呈现。 主要分为两个步骤，一是用爬虫将网页上的小说内容爬取下来；二是将txt文件转化为我们要的epub格式文件，适合电纸书阅读。 一、爬取小说设计思路： 1、封装好，用户输入小说的目录页url地址 2、得到小说所有章节的对应url，组成一个list 3、在url list里面循环，一章一章爬取小说的标题和正文并存储到指定目录 实现过程： 这里我们使用python和它的一些库，包括bs4，requests，retrying。 在爬取的过程中，可能会因为访问过频繁或者网络原因而被拒绝访问。因此我们需要一个重试函数，能够在报错的情况下反复尝试。我们使用retrying和requests库来实现 得到目录页上陈列的各章节链接。这部分每个网站可能不一样，需要根据自己的情况修改 得到每一个章节url对应的标题和内容 我们发现正文中有很多无关内容以及不正常的字符、缩进等，因此我们需要额外写一个文字过滤器，此过滤器在上面get_text()函数中已经调用了。 开始读取内容并存储 爬虫源代码 二、txt文件转化为epub文件我习惯于EPUB格式的电子书，如果你熟悉使用mobi格式的电子书，可以参考书伴网的EasyPub教程来转化，可以配置封面什么的。 这里我使用NeatReader的本地转化器，他们家的产品做的还挺用心的、功能也不错。 另一种选择是使用参考资料1里面的在线转化器，没有使用过，不作评价。 参考资料： 1、TXT转EPUB工具","link":"/2019/12/07/%E9%AA%9A%E6%93%8D%E4%BD%9C/%E8%AE%B0%E4%B8%80%E6%AC%A1%E7%94%B5%E5%AD%90%E4%B9%A6%E7%9A%84%E5%88%B6%E4%BD%9C%EF%BC%88%E4%BB%8E%E7%88%AC%E5%8F%96%E7%BD%91%E4%B8%8A%E8%B5%84%E6%BA%90%E5%BC%80%E5%A7%8B%EF%BC%89/"},{"title":"安卓手机termux安装jupyter","text":"Termux是一个Android下一个高级的终端模拟器, 开源且不需要root, 支持apt管理软件包，十分方便安装软件包, 完美支持Python, PHP, Ruby, Go, Nodejs, MySQL等。随着智能设备的普及和性能的不断提升，如今的手机、平板等的硬件标准已达到了初级桌面计算机的硬件标准, 用心去打造完全可以把手机变成一个强大的工具. 虽然jupyter要安装的话依赖很多，但其实步骤其实很简单。 1234apt update # 更新包apt-get upgrade # 更新包pkg install clang libzmq fftw freetype python #安装依赖pip install jupyter # 安装jupyter 安装完成之后，还可以安装numpy、matplotlib等包 1pip install numpy matplotlib 安装过程可能会很漫长，我在骁龙855的手机上大概用了一两分钟，而在麒麟960的手机上用了大约十分钟还不见结束。至于骁龙625？抱歉，我没有尝试的勇气🙂。 20-7-9更： 之前可能是网络问题，骁龙625的手机在网络条件好的时候经过尝试仅需要不到10分钟。 我给神U道歉~ 参考资料： 1、termux中文网","link":"/2019/12/05/%E9%AA%9A%E6%93%8D%E4%BD%9C/%E5%AE%89%E5%8D%93%E6%89%8B%E6%9C%BAtermux%E5%AE%89%E8%A3%85jupyter/"},{"title":"安卓手机Ksweb食用指南","text":"Ksweb由老毛子开发，是一款可以在手机上部署PHP网页的APP，它没有Termux和Linux Deploy的麻烦，开箱即用，对于PHP程序猿来可以说是歪瑞古德。 一、下载、安装下载链接发在参考资料中，低调自取。 二、目录结构 PHP文件目录：\\htdocs 把PHP文件放到该目录，盘它、盘它！ Ksweb目录：\\ksweb 参考资料： 1、Kslab官网：http://www.kslabs.ru/ 2、APP下载： 蓝奏云（推荐）：https://wws.lanzous.com/ibN2dedkekb 3、百度论坛：https://tieba.baidu.com/f?kw=ksweb","link":"/2020/07/07/%E9%AA%9A%E6%93%8D%E4%BD%9C/%E5%AE%89%E5%8D%93%E6%89%8B%E6%9C%BAKsweb%E9%A3%9F%E7%94%A8%E6%8C%87%E5%8D%97/"},{"title":"红宝书必考词","text":"单词很重要，红宝书很重要！ 参考资料：1、《红宝书》及相关音频","link":"/2020/10/18/%E5%AD%A6%E7%A7%91%E7%AC%94%E8%AE%B0/%E7%BA%A2%E5%AE%9D%E4%B9%A6%E5%BF%85%E8%80%83%E8%AF%8D/"},{"title":"高数18讲难题集【持续更新】","text":"18讲是考研数学复习中几乎人手必备的一本书，我将自己在做题过程中不会的、做错的整理在这里。 参考资料：1、张宇–《高数18讲》及相关视频","link":"/2020/10/18/%E5%AD%A6%E7%A7%91%E7%AC%94%E8%AE%B0/%E9%AB%98%E6%95%B018%E8%AE%B2%E9%9A%BE%E9%A2%98%E9%9B%86/"}],"tags":[{"name":"deepin","slug":"deepin","link":"/tags/deepin/"},{"name":"git","slug":"git","link":"/tags/git/"},{"name":"hexo","slug":"hexo","link":"/tags/hexo/"},{"name":"CAD","slug":"CAD","link":"/tags/CAD/"},{"name":"产品数据","slug":"产品数据","link":"/tags/%E4%BA%A7%E5%93%81%E6%95%B0%E6%8D%AE/"},{"name":"先进制造","slug":"先进制造","link":"/tags/%E5%85%88%E8%BF%9B%E5%88%B6%E9%80%A0/"},{"name":"考研","slug":"考研","link":"/tags/%E8%80%83%E7%A0%94/"},{"name":"机械设计","slug":"机械设计","link":"/tags/%E6%9C%BA%E6%A2%B0%E8%AE%BE%E8%AE%A1/"},{"name":"自动控制","slug":"自动控制","link":"/tags/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6/"},{"name":"python","slug":"python","link":"/tags/python/"},{"name":"database","slug":"database","link":"/tags/database/"},{"name":"php","slug":"php","link":"/tags/php/"},{"name":"windows","slug":"windows","link":"/tags/windows/"},{"name":"单片机","slug":"单片机","link":"/tags/%E5%8D%95%E7%89%87%E6%9C%BA/"},{"name":"C#","slug":"C","link":"/tags/C/"},{"name":"andriod","slug":"andriod","link":"/tags/andriod/"},{"name":"软件推荐","slug":"软件推荐","link":"/tags/%E8%BD%AF%E4%BB%B6%E6%8E%A8%E8%8D%90/"},{"name":"ssh","slug":"ssh","link":"/tags/ssh/"},{"name":"pip","slug":"pip","link":"/tags/pip/"},{"name":"coding","slug":"coding","link":"/tags/coding/"},{"name":"deepin, linux","slug":"deepin-linux","link":"/tags/deepin-linux/"},{"name":"驱动","slug":"驱动","link":"/tags/%E9%A9%B1%E5%8A%A8/"},{"name":"服务器","slug":"服务器","link":"/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"name":"GANs","slug":"GANs","link":"/tags/GANs/"},{"name":"tensorflow2.0","slug":"tensorflow2-0","link":"/tags/tensorflow2-0/"},{"name":"tensorflow","slug":"tensorflow","link":"/tags/tensorflow/"},{"name":"kears","slug":"kears","link":"/tags/kears/"},{"name":"目标检测","slug":"目标检测","link":"/tags/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/"},{"name":"数据预读取","slug":"数据预读取","link":"/tags/%E6%95%B0%E6%8D%AE%E9%A2%84%E8%AF%BB%E5%8F%96/"},{"name":"jupyter","slug":"jupyter","link":"/tags/jupyter/"},{"name":"html","slug":"html","link":"/tags/html/"},{"name":"nginx","slug":"nginx","link":"/tags/nginx/"},{"name":"linux","slug":"linux","link":"/tags/linux/"},{"name":"ubuntu","slug":"ubuntu","link":"/tags/ubuntu/"},{"name":"python, webdav","slug":"python-webdav","link":"/tags/python-webdav/"},{"name":"linux, 安卓, linux deploy","slug":"linux-安卓-linux-deploy","link":"/tags/linux-%E5%AE%89%E5%8D%93-linux-deploy/"},{"name":"samba","slug":"samba","link":"/tags/samba/"},{"name":"爬虫","slug":"爬虫","link":"/tags/%E7%88%AC%E8%99%AB/"},{"name":"Ksweb","slug":"Ksweb","link":"/tags/Ksweb/"},{"name":"建站","slug":"建站","link":"/tags/%E5%BB%BA%E7%AB%99/"}],"categories":[{"name":"hexo","slug":"hexo","link":"/categories/hexo/"},{"name":"学科笔记","slug":"学科笔记","link":"/categories/%E5%AD%A6%E7%A7%91%E7%AC%94%E8%AE%B0/"},{"name":"自学成才","slug":"自学成才","link":"/categories/%E8%87%AA%E5%AD%A6%E6%88%90%E6%89%8D/"},{"name":"小技巧","slug":"小技巧","link":"/categories/%E5%B0%8F%E6%8A%80%E5%B7%A7/"},{"name":"机器学习","slug":"机器学习","link":"/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"骚操作","slug":"骚操作","link":"/categories/%E9%AA%9A%E6%93%8D%E4%BD%9C/"}]}